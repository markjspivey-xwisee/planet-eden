<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planet Eden - Complete AI Life Simulation</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        :root {
            --bg-panel: rgba(10, 17, 40, 0.9);
            --border: rgba(0, 212, 255, 0.3);
            --border-bright: #00d4ff;
            --text-bright: #00d4ff;
            --text-normal: #fff;
            --text-dim: rgba(255, 255, 255, 0.6);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas-container { width: 100vw; height: 100vh; }

        #loading-screen {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a1128 0%, #001F54 100%);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 1000; transition: opacity 0.5s;
        }
        #loading-screen.hidden { opacity: 0; pointer-events: none; }

        .loading-title {
            font-size: 3rem; font-weight: 200; margin-bottom: 2rem;
            background: linear-gradient(135deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            letter-spacing: 8px;
        }

        .loading-bar-container {
            width: 400px; height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px; overflow: hidden;
        }

        .loading-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #7b2ff7);
            width: 0%; transition: width 0.3s;
        }

        .loading-text {
            margin-top: 1rem; font-size: 0.9rem;
            color: rgba(255,255,255,0.5);
        }

        .hud-panel {
            position: fixed;
            background: var(--bg-panel);
            backdrop-filter: blur(15px);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 60px rgba(0, 212, 255, 0.1);
            transition: all 0.3s;
            animation: panelSlideIn 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }

        @keyframes panelSlideIn {
            from {
                opacity: 0;
                transform: translateY(20px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .hud-panel:hover {
            border-color: var(--border-bright);
            box-shadow: 0 0 40px rgba(0, 212, 255, 0.4);
        }

        #stats { top: 20px; right: 20px; min-width: 250px; z-index: 100; }

        #search-panel {
            top: 20px; left: 20px;
            width: 350px; max-height: 520px;
            overflow-y: auto; z-index: 100;
        }

        #creature-detail {
            top: 20px; right: 20px;
            width: 380px; max-height: 600px;
            margin-top: 300px;
            overflow-y: auto; z-index: 100;
            opacity: 0; transition: opacity 0.3s;
        }
        #creature-detail.show { opacity: 1; }

        #graphs-panel {
            bottom: 20px; left: 20px;
            width: 450px; height: 300px;
            z-index: 100;
        }

        #controls {
            bottom: 20px; right: 20px;
            display: flex; gap: 10px; flex-wrap: wrap;
            max-width: 400px; z-index: 100;
        }

        h3 {
            margin-bottom: 1rem; font-weight: 500;
            font-size: 1.1rem; color: var(--text-bright);
            text-shadow: 0 0 10px var(--text-bright);
        }

        .stat-row {
            display: flex; justify-content: space-between;
            margin: 0.5rem 0; padding-bottom: 0.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }

        .stat-label { color: var(--text-dim); font-size: 0.85rem; }
        .stat-value { font-weight: 600; color: var(--text-bright); font-size: 0.9rem; }

        button {
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--border);
            color: white; padding: 0.7rem 1.2rem;
            border-radius: 8px; cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
            z-index: 1;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(0, 212, 255, 0.4), transparent);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.5s, height 0.5s;
            z-index: -1;
        }

        button:hover::before {
            width: 200%;
            height: 200%;
        }

        button:hover {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--border-bright);
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
        }

        button.primary {
            background: linear-gradient(135deg, #00d4ff, #7b2ff7);
            border: none; font-weight: 500;
        }

        .search-input {
            width: 100%; background: rgba(0, 40, 60, 0.6);
            border: 1px solid var(--border);
            color: var(--text-bright); padding: 0.6rem;
            border-radius: 6px; font-size: 0.9rem;
            margin-bottom: 0.8rem;
            font-family: inherit;
        }

        .search-input:focus {
            outline: none; border-color: var(--border-bright);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .filter-group {
            display: flex; gap: 0.5rem;
            margin: 0.8rem 0; flex-wrap: wrap;
        }

        .filter-btn {
            background: rgba(0, 60, 80, 0.5);
            border: 1px solid var(--border);
            color: var(--text-normal);
            padding: 0.4rem 0.8rem;
            border-radius: 6px; cursor: pointer;
            font-size: 0.75rem; transition: all 0.2s;
        }

        .filter-btn:hover {
            border-color: var(--border-bright);
            background: rgba(0, 80, 120, 0.7);
        }

        .filter-btn.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--border-bright);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
        }

        .creature-list {
            max-height: 300px; overflow-y: auto;
        }

        .creature-item {
            background: rgba(0, 40, 60, 0.4);
            border: 1px solid var(--border);
            padding: 0.6rem; margin: 0.4rem 0;
            border-radius: 6px; cursor: pointer;
            transition: all 0.2s;
        }

        .creature-item:hover {
            background: rgba(0, 60, 90, 0.7);
            border-color: var(--border-bright);
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
        }

        .creature-item.selected {
            background: rgba(0, 212, 255, 0.2);
            border-color: var(--border-bright);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.4);
        }

        .creature-name {
            font-weight: 600; color: var(--text-bright);
            margin-bottom: 0.3rem; font-size: 0.9rem;
        }

        .creature-type {
            font-size: 0.75rem; color: var(--text-dim);
        }

        .creature-stats {
            display: flex; gap: 0.6rem;
            margin-top: 0.4rem; font-size: 0.75rem;
            color: var(--text-dim);
        }

        .progress-bar {
            height: 6px; background: rgba(50, 50, 60, 0.5);
            border-radius: 3px; overflow: hidden;
            margin: 0.4rem 0;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }

        .progress-fill {
            height: 100%; transition: width 0.3s;
        }

        .progress-fill.health { background: linear-gradient(90deg, #f00, #0f0); }
        .progress-fill.energy { background: linear-gradient(90deg, #f80, #ff0); }

        .chart-container {
            position: relative; height: 230px;
            margin-top: 0.8rem;
        }

        .notification {
            position: fixed; top: 100px; left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0,212,255,0.95), rgba(123,47,247,0.95));
            padding: 1rem 2rem; border-radius: 12px;
            animation: notificationBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 200;
            box-shadow: 0 8px 32px rgba(0,0,0,0.6), 0 0 60px rgba(0, 212, 255, 0.5);
            border: 2px solid rgba(0, 212, 255, 0.8);
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        @keyframes notificationBounce {
            0% {
                transform: translateX(-50%) translateY(-100px) scale(0.5);
                opacity: 0;
            }
            50% {
                transform: translateX(-50%) translateY(10px) scale(1.05);
            }
            100% {
                transform: translateX(-50%) translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes slideDown {
            from { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }

        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: rgba(0, 20, 30, 0.5); }
        ::-webkit-scrollbar-thumb { background: rgba(0, 212, 255, 0.4); border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(0, 212, 255, 0.6); }

        /* Enhanced Tooltips */
        [title] {
            position: relative;
        }

        button[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(0, 40, 80, 0.98), rgba(20, 60, 100, 0.98));
            color: #fff;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            border: 1px solid var(--border-bright);
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
            animation: tooltipFadeIn 0.2s;
        }

        button[title]:hover::before {
            content: '';
            position: absolute;
            bottom: calc(100% + 2px);
            left: 50%;
            transform: translateX(-50%);
            border: 6px solid transparent;
            border-top-color: rgba(0, 212, 255, 0.8);
            z-index: 1001;
            pointer-events: none;
            animation: tooltipFadeIn 0.2s;
        }

        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(-4px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* ========== GOD MODE STYLES ========== */
        #god-powers-panel {
            left: 20px; top: 560px;
            width: 350px; max-height: calc(100vh - 580px);
            overflow-y: auto;
        }

        .power-category {
            margin-bottom: 1rem;
        }

        .category-header {
            font-size: 0.9rem;
            color: var(--text-bright);
            margin: 0 0 0.5rem 0;
            padding-bottom: 0.3rem;
            border-bottom: 1px solid var(--border);
            position: relative;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
        }

        .category-header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: -100%;
            width: 100%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--border-bright), transparent);
            transition: left 0.5s;
        }

        .category-header:hover::after {
            left: 100%;
        }

        .category-header:hover {
            color: #fff;
            text-shadow: 0 0 15px rgba(0, 212, 255, 0.8);
        }

        .power-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .power-btn {
            padding: 8px 6px;
            font-size: 12px;
            background: rgba(0, 40, 80, 0.4);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .power-btn:hover {
            background: rgba(0, 80, 160, 0.5);
            border-color: var(--border-bright);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.3);
        }

        .power-btn.active {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(123, 47, 247, 0.3));
            border-color: var(--border-bright);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
            animation: pulseGlow 2s infinite;
        }

        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 212, 255, 0.5); }
            50% { box-shadow: 0 0 30px rgba(0, 212, 255, 0.8), 0 0 40px rgba(123, 47, 247, 0.4); }
        }

        .power-settings {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 20, 40, 0.3);
            border-radius: 6px;
        }

        .power-settings input[type="range"] {
            -webkit-appearance: none;
            height: 4px;
            background: rgba(0, 212, 255, 0.2);
            border-radius: 2px;
            outline: none;
            margin-top: 4px;
        }

        .power-settings input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--border-bright);
            border-radius: 50%;
            cursor: pointer;
        }

        .power-settings input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: var(--border-bright);
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        /* Custom Cursors */
        body.cursor-bless { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="gold" stroke-width="2"/><circle cx="12" cy="12" r="2" fill="gold"/></svg>') 12 12, crosshair; }
        body.cursor-curse { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="purple" stroke-width="2"/><circle cx="12" cy="12" r="2" fill="purple"/></svg>') 12 12, crosshair; }
        body.cursor-smite, body.cursor-lightning { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M12 2 L8 12 L12 12 L10 22 L16 10 L12 10 Z" fill="yellow" stroke="red" stroke-width="1"/></svg>') 12 12, crosshair; }
        body.cursor-meteor { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="8" fill="none" stroke="orange" stroke-width="2"/><line x1="2" y1="2" x2="8" y2="8" stroke="orange" stroke-width="2"/></svg>') 12 12, crosshair; }
        body.cursor-raise, body.cursor-lower, body.cursor-smooth, body.cursor-flatten { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="lime" stroke-width="2" stroke-dasharray="4 2"/></svg>') 12 12, crosshair; }
        body.cursor-resurrect { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="cyan" stroke-width="2"/><path d="M12 6 L12 18 M6 12 L18 12" stroke="cyan" stroke-width="2"/></svg>') 12 12, crosshair; }
        body.cursor-plague { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="none" stroke="green" stroke-width="2" stroke-dasharray="2 2"/></svg>') 12 12, crosshair; }

        /* ========== WELCOME & SETTINGS SCREENS ========== */
        #welcome-screen, #settings-panel, #help-panel {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(5, 5, 16, 0.98);
            display: flex; justify-content: center; align-items: center;
            z-index: 999;
            animation: fadeIn 0.5s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .welcome-content, .settings-content, .help-content {
            background: linear-gradient(135deg, rgba(10, 17, 40, 0.95), rgba(20, 30, 60, 0.95));
            border: 2px solid var(--border-bright);
            border-radius: 16px;
            padding: 3rem;
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 212, 255, 0.3);
        }

        .welcome-title {
            font-size: 3.5rem;
            font-weight: 200;
            margin: 0 0 0.5rem 0;
            background: linear-gradient(135deg, #00d4ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            letter-spacing: 4px;
        }

        .welcome-subtitle {
            text-align: center;
            color: var(--text-dim);
            font-size: 1.2rem;
            margin: 0 0 2rem 0;
        }

        .tutorial-section {
            margin: 2rem 0;
        }

        .tutorial-section h2 {
            color: var(--text-bright);
            margin-bottom: 1rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .tutorial-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .tutorial-item {
            background: rgba(0, 40, 80, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s;
        }

        .tutorial-item:hover {
            background: rgba(0, 80, 160, 0.4);
            border-color: var(--border-bright);
            transform: translateY(-4px);
        }

        .tutorial-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .tutorial-item h3 {
            font-size: 1rem;
            color: var(--text-bright);
            margin: 0.5rem 0;
        }

        .tutorial-item p {
            font-size: 0.85rem;
            color: var(--text-dim);
            margin: 0;
            line-height: 1.4;
        }

        .feature-highlights {
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .feature-highlights h2 {
            margin-top: 0;
            color: var(--text-bright);
        }

        .feature-highlights ul {
            margin: 1rem 0;
            padding-left: 1.5rem;
            line-height: 1.8;
        }

        .welcome-actions {
            display: flex;
            gap: 1rem;
            margin: 2rem 0;
        }

        .btn-large {
            flex: 1;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: rgba(0, 40, 80, 0.5);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-large:hover {
            background: rgba(0, 80, 160, 0.6);
            border-color: var(--border-bright);
            transform: scale(1.05);
        }

        .btn-large.btn-primary {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(123, 47, 247, 0.3));
            border-color: var(--border-bright);
        }

        .btn-large.btn-primary:hover {
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .welcome-footer {
            text-align: center;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        /* Settings Panel */
        .setting-group {
            margin: 1.5rem 0;
        }

        .setting-group h3 {
            color: var(--text-bright);
            margin: 0 0 0.5rem 0;
        }

        .setting-group label {
            display: block;
            margin: 0.5rem 0;
            color: var(--text-normal);
        }

        .quality-presets {
            display: flex;
            gap: 0.5rem;
            margin: 0.5rem 0;
        }

        .preset-btn {
            flex: 1;
            padding: 0.75rem;
            background: rgba(0, 40, 80, 0.4);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .preset-btn:hover {
            background: rgba(0, 80, 160, 0.5);
        }

        .preset-btn.active {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.3), rgba(123, 47, 247, 0.3));
            border-color: var(--border-bright);
        }

        .settings-actions {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
        }

        .settings-actions button {
            flex: 1;
            padding: 0.75rem;
            font-size: 1rem;
            border: 2px solid var(--border);
            border-radius: 6px;
            background: rgba(0, 40, 80, 0.5);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }

        .settings-actions button:hover {
            background: rgba(0, 80, 160, 0.6);
            transform: translateY(-2px);
        }

        .settings-actions .btn-primary {
            border-color: var(--border-bright);
        }

        /* Help Panel */
        .shortcut-list {
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .shortcut-list div {
            padding: 0.5rem;
            margin: 0.25rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        kbd {
            background: rgba(0, 212, 255, 0.2);
            border: 1px solid var(--border-bright);
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-family: monospace;
            font-size: 0.9rem;
            min-width: 60px;
            display: inline-block;
            text-align: center;
        }

        /* FPS Counter */
        #fps-counter {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.5rem 1rem;
            font-family: monospace;
            font-size: 0.9rem;
            color: var(--text-bright);
            z-index: 150;
            display: none;
        }

        #fps-counter.show {
            display: block;
        }

        /* Developer Console */
        #dev-console {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50vh;
            background: rgba(5, 5, 16, 0.98);
            border-top: 2px solid var(--border-bright);
            z-index: 1000;
            display: none;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        #dev-console.show {
            display: block;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from { transform: translateY(100%); }
            to { transform: translateY(0); }
        }

        .dev-console-header {
            background: linear-gradient(135deg, rgba(0, 40, 80, 0.8), rgba(20, 10, 40, 0.8));
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .dev-console-tabs {
            display: flex;
            gap: 0.5rem;
        }

        .dev-tab {
            padding: 0.5rem 1rem;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-normal);
            cursor: pointer;
            transition: all 0.2s;
        }

        .dev-tab.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--border-bright);
            color: var(--text-bright);
        }

        .dev-tab:hover {
            background: rgba(0, 212, 255, 0.2);
        }

        .dev-console-content {
            padding: 1rem;
        }

        .dev-section {
            display: none;
        }

        .dev-section.active {
            display: block;
        }

        .dev-metric {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem;
            margin: 0.25rem 0;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 4px;
            border-left: 3px solid var(--border-bright);
        }

        .dev-metric-label {
            color: var(--text-dim);
        }

        .dev-metric-value {
            color: var(--text-bright);
            font-weight: bold;
        }

        #neural-network-viz {
            width: 100%;
            height: 300px;
            background: rgba(0, 20, 40, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            position: relative;
        }

        #performance-graph {
            width: 100%;
            height: 200px;
            background: rgba(0, 20, 40, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        /* Developer Settings Panel */
        #dev-settings-panel {
            position: fixed;
            right: 20px;
            top: 80px;
            width: 300px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            z-index: 200;
            display: none;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        #dev-settings-panel.show {
            display: block;
            animation: panelSlideIn 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .dev-slider-group {
            margin: 1rem 0;
        }

        .dev-slider-group label {
            display: block;
            color: var(--text-normal);
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .dev-slider-group input[type="range"] {
            width: 100%;
            height: 6px;
            background: rgba(0, 212, 255, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .dev-slider-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--border-bright);
            border-radius: 50%;
            cursor: pointer;
        }

        .dev-slider-value {
            color: var(--text-bright);
            font-weight: bold;
            float: right;
        }

        /* Code Viewer Modal */
        #code-viewer-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.98);
            z-index: 1500;
            display: none;
            overflow-y: auto;
        }

        #code-viewer-modal.show {
            display: flex;
            flex-direction: column;
            animation: fadeIn 0.3s;
        }

        .code-viewer-header {
            padding: 1.5rem;
            background: linear-gradient(135deg, rgba(0, 40, 80, 0.8), rgba(20, 10, 40, 0.8));
            border-bottom: 2px solid var(--border-bright);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-viewer-content {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
        }

        .code-block {
            background: rgba(0, 20, 40, 0.8);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.6;
            overflow-x: auto;
            white-space: pre;
        }

        .code-section-title {
            color: var(--text-bright);
            margin: 2rem 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        /* Evolution Timeline */
        #evolution-timeline {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 1000px;
            height: 200px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 1rem;
            z-index: 250;
            display: none;
        }

        #evolution-timeline.show {
            display: block;
            animation: panelSlideIn 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .timeline-canvas {
            width: 100%;
            height: 150px;
            background: rgba(0, 20, 40, 0.5);
            border-radius: 8px;
        }

        /* Export Buttons */
        .export-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin: 1rem 0;
        }

        .export-btn {
            padding: 0.5rem 1rem;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-bright);
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85rem;
        }

        .export-btn:hover {
            background: rgba(0, 212, 255, 0.3);
            border-color: var(--border-bright);
            transform: translateY(-2px);
        }

        /* Spatial Grid Overlay */
        .spatial-grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        /* Matrix Mode Easter Egg */
        .matrix-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            display: none;
        }

        .matrix-rain.active {
            display: block;
        }

        /* Benchmark Results */
        #benchmark-results {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            border: 2px solid var(--border-bright);
            border-radius: 12px;
            padding: 2rem;
            z-index: 1500;
            display: none;
            max-width: 600px;
            box-shadow: 0 20px 60px rgba(0, 212, 255, 0.3);
        }

        #benchmark-results.show {
            display: block;
            animation: notificationBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .benchmark-score {
            font-size: 3rem;
            color: var(--border-bright);
            text-align: center;
            margin: 1rem 0;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }

        .benchmark-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        /* Family Tree Visualization */
        #family-tree-viz {
            width: 100%;
            height: 250px;
            background: rgba(0, 20, 40, 0.3);
            border: 1px solid var(--border);
            border-radius: 8px;
            margin: 1rem 0;
            position: relative;
            overflow: auto;
        }

        .tree-node {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid var(--border-bright);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tree-node:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
        }

        .tree-line {
            position: absolute;
            background: var(--border);
            height: 2px;
        }

        /* Developer Tools Menu - Mobile First */
        #dev-tools-menu {
            position: fixed;
            bottom: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 300;
        }

        .dev-menu-btn {
            background: rgba(0, 40, 80, 0.95);
            border: 2px solid var(--border-bright);
            border-radius: 12px;
            padding: 12px 16px;
            color: var(--text-bright);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5);
            min-width: 140px;
            min-height: 44px; /* Touch-friendly */
        }

        .dev-menu-btn:hover {
            background: rgba(0, 80, 160, 0.95);
            transform: translateX(-5px);
            box-shadow: 0 6px 24px rgba(0, 212, 255, 0.6);
        }

        .dev-menu-btn:active {
            transform: translateX(-3px) scale(0.98);
        }

        .dev-menu-btn .emoji {
            font-size: 18px;
        }

        /* Floating Action Menu Toggle */
        #dev-menu-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.9), rgba(123, 47, 247, 0.9));
            border: 2px solid var(--border-bright);
            border-radius: 50%;
            width: 56px;
            height: 56px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 301;
            transition: all 0.3s;
            box-shadow: 0 6px 20px rgba(0, 212, 255, 0.5);
            font-size: 24px;
        }

        #dev-menu-toggle:hover {
            transform: scale(1.1) rotate(90deg);
            box-shadow: 0 8px 30px rgba(0, 212, 255, 0.8);
        }

        #dev-menu-toggle:active {
            transform: scale(1.05) rotate(90deg);
        }

        #dev-tools-menu.hidden {
            display: none;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            #dev-tools-menu {
                bottom: 70px;
                right: 10px;
                gap: 8px;
            }

            .dev-menu-btn {
                padding: 10px 14px;
                font-size: 13px;
                min-width: 120px;
            }

            #dev-menu-toggle {
                width: 50px;
                height: 50px;
                bottom: 15px;
                right: 15px;
                font-size: 20px;
            }

            #dev-console {
                height: 60vh;
                font-size: 10px;
            }

            #dev-settings-panel {
                right: 10px;
                top: 60px;
                width: calc(100% - 20px);
                max-width: 320px;
            }

            .dev-console-tabs {
                flex-wrap: wrap;
            }

            .dev-tab {
                font-size: 11px;
                padding: 0.4rem 0.8rem;
            }

            #code-viewer-modal .code-viewer-content {
                padding: 1rem;
            }

            .code-block {
                font-size: 10px;
                padding: 1rem;
            }

            #evolution-timeline {
                width: 95%;
                bottom: 60px;
            }

            #benchmark-results {
                width: 90%;
                max-width: none;
                padding: 1.5rem;
            }

            .benchmark-score {
                font-size: 2rem;
            }

            /* Make HUD panels mobile-friendly */
            .hud-panel {
                font-size: 0.85rem;
                padding: 1rem;
            }

            #god-powers-panel {
                width: calc(100% - 40px);
                max-width: 300px;
            }
        }

        @media (max-width: 480px) {
            #dev-console {
                height: 70vh;
            }

            .dev-menu-btn {
                min-width: 100px;
                padding: 8px 12px;
                font-size: 12px;
            }

            .export-buttons {
                flex-direction: column;
            }

            .export-btn {
                width: 100%;
            }

            .dev-slider-group label {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="loading-screen">
        <div class="loading-title">PLANET EDEN</div>
        <div class="loading-bar-container">
            <div class="loading-bar" id="loading-bar"></div>
        </div>
        <div class="loading-text" id="loading-text">Generating planet...</div>
    </div>

    <div id="welcome-screen" style="display: none;">
        <div class="welcome-content">
            <h1 class="welcome-title">üåç PLANET EDEN</h1>
            <p class="welcome-subtitle">God Mode Simulation</p>

            <div class="tutorial-section">
                <h2>üéÆ How to Play</h2>
                <div class="tutorial-grid">
                    <div class="tutorial-item">
                        <div class="tutorial-icon">üñ±Ô∏è</div>
                        <h3>Camera Controls</h3>
                        <p>Drag to rotate ‚Ä¢ Scroll to zoom</p>
                    </div>
                    <div class="tutorial-item">
                        <div class="tutorial-icon">‚ö°</div>
                        <h3>God Powers</h3>
                        <p>Select power ‚Üí Click to use<br>Press ESC to cancel</p>
                    </div>
                    <div class="tutorial-item">
                        <div class="tutorial-icon">‚å®Ô∏è</div>
                        <h3>Shortcuts</h3>
                        <p>Space: Pause ‚Ä¢ H: Help<br>S: Settings ‚Ä¢ Q/E: Speed</p>
                    </div>
                    <div class="tutorial-item">
                        <div class="tutorial-icon">üéØ</div>
                        <h3>Select Creatures</h3>
                        <p>Click organisms to view stats<br>Use powers on selected</p>
                    </div>
                </div>
            </div>

            <div class="feature-highlights">
                <h2>‚ú® Features</h2>
                <ul>
                    <li>22 God Powers across 4 categories</li>
                    <li>Real-time terrain sculpting</li>
                    <li>Neural network evolution AI</li>
                    <li>Dynamic ecosystem simulation</li>
                </ul>
            </div>

            <div class="welcome-actions">
                <button id="btn-start-game" class="btn-large btn-primary">‚ñ∂ Start Simulation</button>
                <button id="btn-show-settings" class="btn-large">‚öôÔ∏è Settings</button>
            </div>

            <div class="welcome-footer">
                <label style="color: rgba(255,255,255,0.6); font-size: 0.9rem;">
                    <input type="checkbox" id="skip-tutorial"> Don't show this again
                </label>
            </div>
        </div>
    </div>

    <div id="settings-panel" style="display: none;">
        <div class="settings-content">
            <h2>‚öôÔ∏è Settings</h2>

            <div class="setting-group">
                <h3>Graphics Quality</h3>
                <div class="quality-presets">
                    <button class="preset-btn" data-preset="low">Low</button>
                    <button class="preset-btn active" data-preset="medium">Medium</button>
                    <button class="preset-btn" data-preset="high">High</button>
                </div>
            </div>

            <div class="setting-group">
                <label>
                    <input type="checkbox" id="setting-particles" checked> Particle Effects
                </label>
                <label>
                    <input type="checkbox" id="setting-shadows"> Shadows (impacts performance)
                </label>
                <label>
                    <input type="checkbox" id="setting-sound" checked> Sound Effects
                </label>
                <label>
                    <input type="checkbox" id="setting-fps" checked> Show FPS Counter
                </label>
            </div>

            <div class="setting-group">
                <h3>Game Settings</h3>
                <label>
                    Starting Population: <span id="pop-value">Normal</span>
                </label>
                <input type="range" id="setting-population" min="0" max="2" value="1" step="1">
                <small>Low ‚Ä¢ Normal ‚Ä¢ High</small>
            </div>

            <div class="settings-actions">
                <button id="btn-save-settings" class="btn-primary">Save Settings</button>
                <button id="btn-close-settings">Cancel</button>
            </div>
        </div>
    </div>

    <div id="help-panel" style="display: none;">
        <div class="help-content">
            <h2>üìñ Help & Controls</h2>

            <h3>‚öôÔ∏è Developer Tools</h3>
            <p>Click the <strong>‚öôÔ∏è</strong> button (bottom-right) to access:</p>
            <div class="shortcut-list">
                <div>üìä <strong>Performance</strong> - View FPS, draw calls, memory usage</div>
                <div>üîß <strong>Settings</strong> - Adjust mutation rate, reproduction, energy costs</div>
                <div>‚ö° <strong>Benchmark</strong> - Test performance and get a score</div>
                <div>üìú <strong>View Code</strong> - See implementation examples</div>
                <div>üíæ <strong>Export</strong> - Download data (CSV, JSON, organism DNA)</div>
            </div>

            <h3>Keyboard Shortcuts</h3>
            <div class="shortcut-list">
                <div><kbd>Space</kbd> Pause/Resume</div>
                <div><kbd>H</kbd> Toggle Help</div>
                <div><kbd>S</kbd> Settings</div>
                <div><kbd>Q</kbd> Decrease Speed</div>
                <div><kbd>E</kbd> Increase Speed</div>
                <div><kbd>ESC</kbd> Cancel Power</div>
                <div><kbd>Ctrl+S</kbd> Save World</div>
                <div><kbd>Ctrl+L</kbd> Load World</div>
            </div>

            <h3>Power Categories</h3>
            <p><strong>Divine Intervention:</strong> Directly affect individual creatures</p>
            <p><strong>Environmental:</strong> Area-of-effect powers</p>
            <p><strong>Terraforming:</strong> Reshape the planet</p>
            <p><strong>Resources:</strong> Manage populations</p>

            <button id="btn-close-help" class="btn-primary">Close</button>
        </div>
    </div>

    <div id="fps-counter">60 FPS</div>

    <div id="canvas-container"></div>

    <div id="stats" class="hud-panel">
        <h3>üåç Ecosystem</h3>
        <div class="stat-row">
            <span class="stat-label">üå≥ Plants</span>
            <span class="stat-value" id="plant-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">ü¶å Herbivores</span>
            <span class="stat-value" id="herbivore-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">ü¶Å Carnivores</span>
            <span class="stat-value" id="carnivore-count">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">üë§ Humanoids</span>
            <span class="stat-value" id="humanoid-count">0</span>
        </div>
        <div class="stat-row" style="border: none;">
            <span class="stat-label">üìÖ Day</span>
            <span class="stat-value" id="day-count">0</span>
        </div>
    </div>

    <div id="search-panel" class="hud-panel">
        <h3>üîç Search Creatures</h3>
        <input type="text" class="search-input" id="search-input" placeholder="Search by ID or type...">
        <div class="filter-group">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="plant">üå≥ Plants</button>
            <button class="filter-btn" data-filter="herbivore">ü¶å Herbivores</button>
            <button class="filter-btn" data-filter="carnivore">ü¶Å Carnivores</button>
            <button class="filter-btn" data-filter="humanoid">üë§ Humanoids</button>
        </div>
        <div class="creature-list" id="creature-list"></div>
    </div>

    <div id="creature-detail" class="hud-panel">
        <h3>üìä Creature Detail</h3>
        <div id="creature-info"></div>
    </div>

    <div id="graphs-panel" class="hud-panel">
        <h3>üìà Population Dynamics</h3>
        <div class="chart-container">
            <canvas id="population-chart"></canvas>
        </div>
    </div>

    <div id="god-powers-panel" class="hud-panel">
        <h3>‚ö° God Powers</h3>

        <div id="active-power-indicator" style="display: none;">
            <div style="background: rgba(255, 215, 0, 0.2); padding: 8px; border-radius: 6px; margin-bottom: 10px; border: 1px solid var(--border-bright);">
                <strong style="color: var(--border-bright);">Active:</strong>
                <span id="active-power-name" style="color: #fff;"></span>
                <button id="deselect-power" style="float: right; padding: 2px 8px; font-size: 11px;">‚úï</button>
            </div>
        </div>

        <div class="power-category">
            <h4 class="category-header">‚ú® Divine Intervention</h4>
            <div class="power-grid">
                <button class="power-btn" data-power="bless" title="Boost energy & health">üôè Bless</button>
                <button class="power-btn" data-power="curse" title="Drain energy & health">üíÄ Curse</button>
                <button class="power-btn" data-power="smite" title="Kill with lightning">‚ö° Smite</button>
                <button class="power-btn" data-power="resurrect" title="Restore dead creature">üåü Resurrect</button>
                <button class="power-btn" data-power="evolve" title="Mutate brain 5x">üß¨ Evolve</button>
                <button class="power-btn" data-power="clone" title="Create identical copy">üë• Clone</button>
                <button class="power-btn" data-power="boost-iq" title="Double intelligence">üß† Boost IQ</button>
            </div>
        </div>

        <div class="power-category">
            <h4 class="category-header">üå™Ô∏è Environmental</h4>
            <div class="power-grid">
                <button class="power-btn" data-power="meteor" title="Destroy area with meteor">‚òÑÔ∏è Meteor</button>
                <button class="power-btn" data-power="lightning" title="Strike target">‚ö° Lightning</button>
                <button class="power-btn" data-power="plague" title="Spread disease">ü¶† Plague</button>
                <button class="power-btn" data-power="heal-rain" title="Restore health in area">üåßÔ∏è Heal Rain</button>
                <button class="power-btn" data-power="abundance" title="Spawn many plants">üåø Abundance</button>
                <button class="power-btn" data-power="drought" title="Kill plants in area">üèúÔ∏è Drought</button>
            </div>
        </div>

        <div class="power-category">
            <h4 class="category-header">üèîÔ∏è Terraforming</h4>
            <div class="power-grid">
                <button class="power-btn" data-power="raise" title="Raise terrain height">‚õ∞Ô∏è Raise</button>
                <button class="power-btn" data-power="lower" title="Lower terrain height">üåä Lower</button>
                <button class="power-btn" data-power="smooth" title="Smooth terrain">üìè Smooth</button>
                <button class="power-btn" data-power="flatten" title="Level terrain">üü© Flatten</button>
            </div>
            <div class="power-settings">
                <label style="font-size: 11px; color: var(--text-dim);">
                    Brush Size: <span id="brush-size-value">10</span>
                </label>
                <input type="range" id="brush-size-slider" min="5" max="30" value="10" step="1" style="width: 100%;">
            </div>
        </div>

        <div class="power-category">
            <h4 class="category-header">üì¶ Resources</h4>
            <div class="power-grid">
                <button class="power-btn" data-power="mass-spawn" title="Spawn 50 organisms">üéØ Mass Spawn</button>
                <button class="power-btn" data-power="clear-area" title="Remove all in area">üí• Clear Area</button>
                <button class="power-btn" data-power="balance" title="Balance populations">‚öñÔ∏è Balance</button>
                <button class="power-btn" data-power="surplus" title="Boost plant growth">üåæ Surplus</button>
                <button class="power-btn" data-power="famine" title="Reduce plant growth">ü•Ä Famine</button>
            </div>
        </div>
    </div>

    <div id="controls" class="hud-panel">
        <button id="btn-pause" title="Pause/Resume simulation (Space)">‚è∏ Pause</button>
        <button id="btn-speed" title="Change simulation speed (Q/E)">‚è© 1x</button>
        <button class="primary" id="btn-evolve" title="Trigger evolution event">‚ö° Evolve</button>
        <button id="btn-spawn-plants" title="Add 10 plants">üå≥ +Plants</button>
        <button id="btn-spawn-herbivores" title="Add 5 herbivores">ü¶å +Herbivores</button>
        <button id="btn-spawn-carnivores" title="Add 3 carnivores">ü¶Å +Carnivores</button>
        <button id="btn-spawn-humanoids" title="Add 2 humanoids">üë§ +Humanoids</button>
    </div>

    <!-- Developer Console -->
    <div id="dev-console">
        <div class="dev-console-header">
            <div class="dev-console-tabs">
                <button class="dev-tab active" data-tab="performance">‚ö° Performance</button>
                <button class="dev-tab" data-tab="neural">üß† Neural Network</button>
                <button class="dev-tab" data-tab="entity">üìä Entities</button>
                <button class="dev-tab" data-tab="export">üíæ Export</button>
            </div>
            <button id="close-dev-console" style="padding: 0.5rem 1rem; border-radius: 4px;">‚úï Close</button>
        </div>
        <div class="dev-console-content">
            <div id="performance-section" class="dev-section active">
                <h3 style="color: var(--text-bright); margin-bottom: 1rem;">Performance Metrics</h3>
                <div class="dev-metric">
                    <span class="dev-metric-label">Frame Time:</span>
                    <span class="dev-metric-value" id="metric-frame-time">0ms</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Draw Calls:</span>
                    <span class="dev-metric-value" id="metric-draw-calls">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Triangles:</span>
                    <span class="dev-metric-value" id="metric-triangles">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Active Particles:</span>
                    <span class="dev-metric-value" id="metric-particles">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Memory (MB):</span>
                    <span class="dev-metric-value" id="metric-memory">0</span>
                </div>
                <canvas id="performance-graph"></canvas>
            </div>
            <div id="neural-section" class="dev-section">
                <h3 style="color: var(--text-bright); margin-bottom: 1rem;">Neural Network Visualization</h3>
                <p style="color: var(--text-dim); margin-bottom: 1rem;">Select an organism to view its brain</p>
                <canvas id="neural-network-viz"></canvas>
                <div id="neural-weights" style="margin-top: 1rem; font-size: 10px; color: var(--text-dim);"></div>
            </div>
            <div id="entity-section" class="dev-section">
                <h3 style="color: var(--text-bright); margin-bottom: 1rem;">Entity Statistics</h3>
                <div class="dev-metric">
                    <span class="dev-metric-label">Total Organisms:</span>
                    <span class="dev-metric-value" id="metric-total-organisms">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Living:</span>
                    <span class="dev-metric-value" id="metric-living">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Dead:</span>
                    <span class="dev-metric-value" id="metric-dead">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Avg Generation:</span>
                    <span class="dev-metric-value" id="metric-avg-gen">0</span>
                </div>
                <div class="dev-metric">
                    <span class="dev-metric-label">Spatial Grid Cells:</span>
                    <span class="dev-metric-value" id="metric-grid-cells">0</span>
                </div>
                <div style="margin-top: 1rem;">
                    <label style="color: var(--text-normal);">
                        <input type="checkbox" id="toggle-spatial-grid"> Show Spatial Grid Overlay
                    </label>
                </div>
            </div>
            <div id="export-section" class="dev-section">
                <h3 style="color: var(--text-bright); margin-bottom: 1rem;">Data Export & Analysis</h3>
                <div class="export-buttons">
                    <button class="export-btn" id="export-csv">üìä Export Population CSV</button>
                    <button class="export-btn" id="export-json">üì¶ Export World JSON</button>
                    <button class="export-btn" id="export-benchmark">‚ö° Export Benchmark</button>
                    <button class="export-btn" id="export-organism">üß¨ Export Selected Organism</button>
                </div>
                <div id="export-status" style="margin-top: 1rem; color: var(--text-dim); font-size: 12px;"></div>
            </div>
        </div>
    </div>

    <!-- Developer Settings Panel -->
    <div id="dev-settings-panel">
        <h3 style="color: var(--text-bright); margin-bottom: 1rem;">üîß Developer Settings</h3>
        <p style="color: var(--text-dim); font-size: 0.85rem; margin-bottom: 1rem;">Live parameter tweaking</p>

        <div class="dev-slider-group">
            <label>
                Mutation Rate: <span class="dev-slider-value" id="val-mutation">10%</span>
            </label>
            <input type="range" id="slider-mutation" min="0" max="100" value="10">
        </div>

        <div class="dev-slider-group">
            <label>
                Reproduction Threshold: <span class="dev-slider-value" id="val-reproduction">60</span>
            </label>
            <input type="range" id="slider-reproduction" min="30" max="90" value="60">
        </div>

        <div class="dev-slider-group">
            <label>
                Energy Cost Multiplier: <span class="dev-slider-value" id="val-energy">1.0x</span>
            </label>
            <input type="range" id="slider-energy" min="0.1" max="3" step="0.1" value="1">
        </div>

        <div class="dev-slider-group">
            <label>
                AI Perception Range: <span class="dev-slider-value" id="val-perception">20</span>
            </label>
            <input type="range" id="slider-perception" min="5" max="50" value="20">
        </div>

        <div class="dev-slider-group">
            <label>
                Evolution Speed: <span class="dev-slider-value" id="val-evo-speed">1.0x</span>
            </label>
            <input type="range" id="slider-evo-speed" min="0.1" max="5" step="0.1" value="1">
        </div>

        <div class="dev-slider-group">
            <label>
                Planet Gravity: <span class="dev-slider-value" id="val-gravity">1.0x</span>
            </label>
            <input type="range" id="slider-gravity" min="0.1" max="3" step="0.1" value="1">
        </div>

        <button id="reset-dev-settings" style="width: 100%; margin-top: 1rem; padding: 0.75rem;">
            ‚Üª Reset to Defaults
        </button>
    </div>

    <!-- Code Viewer Modal -->
    <div id="code-viewer-modal">
        <div class="code-viewer-header">
            <h2 style="color: var(--text-bright); margin: 0;">üìú Source Code</h2>
            <button id="close-code-viewer" style="padding: 0.5rem 1rem; border-radius: 4px;">‚úï Close</button>
        </div>
        <div class="code-viewer-content">
            <p style="color: var(--text-normal); margin-bottom: 2rem;">
                Single-file architecture: 3,290+ lines of vanilla JavaScript, Three.js, and Chart.js
            </p>
            <div id="code-content">
                <div class="code-section-title" id="code-ai">üß† AI & Neural Networks</div>
                <div class="code-block">// NeuralNetwork class with feedforward architecture
//Simple 3-layer network: Input ‚Üí Hidden ‚Üí Output
// Organisms use this for decision-making

class NeuralNetwork {
    constructor(inputSize, hiddenSize, outputSize) {
        // Initialize weights with random values
        this.weightsIH = Array(inputSize).fill().map(() =>
            Array(hiddenSize).fill().map(() => Math.random() * 2 - 1)
        );
        this.weightsHO = Array(hiddenSize).fill().map(() =>
            Array(outputSize).fill().map(() => Math.random() * 2 - 1)
        );
    }

    // Feedforward propagation
    predict(inputs) {
        const hidden = this.weightsIH[0].map((_, h) =>
            inputs.reduce((sum, input, i) =>
                sum + input * this.weightsIH[i][h], 0
            )
        ).map(x => Math.tanh(x)); // Activation function

        const outputs = this.weightsHO[0].map((_, o) =>
            hidden.reduce((sum, h, i) =>
                sum + h * this.weightsHO[i][o], 0
            )
        ).map(x => Math.tanh(x));

        return outputs;
    }

    // Mutation for evolution
    mutate() {
        const mutateMatrix = (matrix) => {
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    if (Math.random() < 0.1) { // 10% mutation rate
                        matrix[i][j] += (Math.random() - 0.5) * 0.5;
                    }
                }
            }
        };
        mutateMatrix(this.weightsIH);
        mutateMatrix(this.weightsHO);
    }
}</div>

                <div class="code-section-title" id="code-physics">‚öôÔ∏è Physics & Movement</div>
                <div class="code-block">// Organisms stick to spherical planet surface using normal vectors
// Velocity is projected onto tangent plane for smooth movement

function moveOnSphere(organism, direction, speed) {
    const normal = organism.position.clone().normalize();

    // Project direction onto tangent plane
    const tangentDirection = direction.clone()
        .sub(normal.clone().multiplyScalar(direction.dot(normal)))
        .normalize();

    // Apply movement
    organism.position.add(tangentDirection.multiplyScalar(speed));

    // Snap back to sphere surface
    organism.position.normalize().multiplyScalar(PLANET_RADIUS);

    // Update rotation to face surface normal
    organism.mesh.up.copy(normal);
    organism.mesh.lookAt(
        organism.position.clone().add(tangentDirection)
    );
}</div>

                <div class="code-section-title" id="code-powers">‚ö° God Powers System</div>
                <div class="code-block">// Declarative power system - each power has target type and execute function
// Supports 4 target types: creature, location, terraform, global

const POWERS = {
    'smite': {
        name: 'Smite',
        targetType: 'creature',
        execute: (organism) => {
            const skyPos = organism.position.clone()
                .normalize().multiplyScalar(PLANET_RADIUS + 30);
            createLightningEffect(skyPos, organism.position);
            organism.die();
            playSound(200, 300);
        }
    },
    'terraform': {
        name: 'Raise Terrain',
        targetType: 'terraform',
        execute: (clickPoint) => {
            // Direct vertex manipulation with falloff
            const positions = planetGeometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const vertex = new THREE.Vector3(
                    positions.getX(i),
                    positions.getY(i),
                    positions.getZ(i)
                );
                const dist = vertex.distanceTo(clickPoint);
                if (dist < brushSize) {
                    const falloff = 1 - (dist / brushSize);
                    const newLen = vertex.length() + strength * falloff;
                    vertex.normalize().multiplyScalar(newLen);
                    positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
                }
            }
            planetGeometry.computeVertexNormals();
        }
    }
};</div>

                <div class="code-section-title" id="code-render">üé® Rendering & Effects</div>
                <div class="code-block">// Particle system with gravity, spiral motion, and size animation
// Auto-disposal after lifecycle completes

class ParticleEffect {
    update(delta) {
        const progress = this.timer / this.duration;

        for (let i = 0; i < this.particleCount; i++) {
            const particle = this.particles[i];

            // Apply gravity
            particle.velocity.y -= delta * 2;

            // Add spiral effect
            const angle = this.timer * 0.005;
            positions[i*3] += Math.cos(angle + i) * 0.1 * delta;
            positions[i*3+2] += Math.sin(angle + i) * 0.1 * delta;

            // Animate size
            sizes[i] = (0.2 + Math.sin(progress * Math.PI) * 0.8);
        }

        // Smooth fade out
        this.mesh.material.opacity = 1 - Math.pow(progress, 2);

        return progress >= 1; // Signal completion
    }
}</div>
            </div>
        </div>
    </div>

    <!-- Evolution Timeline -->
    <div id="evolution-timeline">
        <h3 style="color: var(--text-bright); margin: 0 0 0.5rem 0;">üß¨ Evolution Timeline</h3>
        <canvas class="timeline-canvas" id="timeline-canvas"></canvas>
        <div style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--text-dim);">
            <span id="timeline-info">Hover over timeline to see generation details</span>
        </div>
    </div>

    <!-- Benchmark Results Modal -->
    <div id="benchmark-results">
        <h2 style="color: var(--text-bright); text-align: center;">‚ö° Performance Benchmark</h2>
        <div class="benchmark-score" id="benchmark-score">0</div>
        <p style="text-align: center; color: var(--text-normal); margin-bottom: 1rem;" id="benchmark-rating">-</p>
        <div class="benchmark-details">
            <div class="dev-metric">
                <span class="dev-metric-label">Avg FPS:</span>
                <span class="dev-metric-value" id="bench-fps">0</span>
            </div>
            <div class="dev-metric">
                <span class="dev-metric-label">Frame Time:</span>
                <span class="dev-metric-value" id="bench-frame-time">0ms</span>
            </div>
            <div class="dev-metric">
                <span class="dev-metric-label">Max Entities:</span>
                <span class="dev-metric-value" id="bench-entities">0</span>
            </div>
            <div class="dev-metric">
                <span class="dev-metric-label">GPU:</span>
                <span class="dev-metric-value" id="bench-gpu">-</span>
            </div>
        </div>
        <div class="export-buttons" style="justify-content: center; margin-top: 1.5rem;">
            <button class="export-btn" id="share-benchmark">üì¢ Share Results</button>
            <button class="export-btn" id="close-benchmark">‚úï Close</button>
        </div>
    </div>

    <!-- Matrix Rain Canvas (Easter Egg) -->
    <canvas class="matrix-rain" id="matrix-rain"></canvas>

    <!-- Developer Tools Floating Action Menu -->
    <button id="dev-menu-toggle" title="Developer Tools">
        ‚öôÔ∏è
    </button>

    <div id="dev-tools-menu" class="hidden">
        <button class="dev-menu-btn" id="btn-dev-console">
            <span class="emoji">üìä</span> Performance
        </button>
        <button class="dev-menu-btn" id="btn-dev-settings">
            <span class="emoji">üîß</span> Settings
        </button>
        <button class="dev-menu-btn" id="btn-benchmark">
            <span class="emoji">‚ö°</span> Benchmark
        </button>
        <button class="dev-menu-btn" id="btn-code-viewer">
            <span class="emoji">üìú</span> View Code
        </button>
        <button class="dev-menu-btn" id="btn-export-menu">
            <span class="emoji">üíæ</span> Export
        </button>
    </div>

    <script>
        function showNotification(msg) {
            const n = document.createElement('div');
            n.className = 'notification';
            n.textContent = msg;
            document.body.appendChild(n);
            setTimeout(() => n.remove(), 3000);
        }

        (function() {
            const libs = {
                three: {
                    name: 'THREE',
                    urls: [
                        'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js',
                        'https://unpkg.com/three@0.158.0/build/three.min.js'
                    ]
                },
                chart: {
                    name: 'Chart',
                    urls: [
                        'https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js',
                        'https://unpkg.com/chart.js@4.4.0/dist/chart.umd.min.js'
                    ]
                }
            };

            let loaded = 0;

            function updateProgress(p, t) {
                document.getElementById('loading-bar').style.width = p + '%';
                document.getElementById('loading-text').textContent = t;
            }

            function loadScript(url) {
                return new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = url;
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                });
            }

            function tryLoad(lib, i = 0) {
                return new Promise((resolve, reject) => {
                    if (i >= lib.urls.length) {
                        reject(new Error('Failed'));
                        return;
                    }
                    loadScript(lib.urls[i])
                        .then(() => window[lib.name] ? resolve() : Promise.reject())
                        .catch(() => tryLoad(lib, i + 1).then(resolve).catch(reject));
                });
            }

            Promise.all([
                tryLoad(libs.three).then(() => { loaded++; updateProgress(50, 'Loading graphics...'); }),
                tryLoad(libs.chart).then(() => { loaded++; updateProgress(80, 'Loading charts...'); })
            ])
            .then(() => {
                updateProgress(100, 'Ready!');
                setTimeout(() => {
                    document.getElementById('loading-screen').classList.add('hidden');
                }, 300);
                init();
            })
            .catch(() => {
                updateProgress(0, 'Failed to load. Check connection.');
            });
        })();

        function init() {
            /* ==================== PERFORMANCE OPTIMIZATIONS ====================
             * 1. Terrain Height Cache - Caches terrain heights in 64x64 grid to avoid expensive calculations
             * 2. Spatial Grid - O(n) collision detection AND thinking instead of O(n¬≤)
             * 3. Throttled UI Updates - Counts update every 5 frames, charts every 10, lists every 30
             * 4. Cached Organism Counts - Single loop instead of 4 filter() calls per frame
             * 5. Shadows Disabled - Major performance boost by disabling real-time shadows
             * 6. Reduced Pixel Ratio - 1.5x max instead of 2x for lower resolution rendering
             * 7. Population Cap - Maximum 200 organisms to prevent exponential lag
             * 8. Optimized Geometry - Planet 320x320, Atmosphere 32x32 (reduced from 512/64)
             * 9. Procedural Terrain Heights - Direct calculation instead of raycasting
             * 10. Optimized Noise Functions - Hash-based with cache-friendly operations
             * =================================================================== */

            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050510);
            scene.fog = new THREE.FogExp2(0x050510, 0.00012);

            const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 60, 140);

            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Reduced pixel ratio for better performance
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            // Disable shadows for significant performance boost
            renderer.shadowMap.enabled = false;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffee, 1.8);
            sunLight.position.set(100, 150, -300);
            sunLight.castShadow = true;
            // Reduced shadow map size for better performance
            sunLight.shadow.mapSize.width = 1024;
            sunLight.shadow.mapSize.height = 1024;
            sunLight.shadow.camera.left = -150;
            sunLight.shadow.camera.right = 150;
            sunLight.shadow.camera.top = 150;
            sunLight.shadow.camera.bottom = -150;
            scene.add(sunLight);

            const fillLight = new THREE.DirectionalLight(0x8888ff, 0.3);
            fillLight.position.set(-50, 50, 100);
            scene.add(fillLight);

            // ========== HIGH RESOLUTION PLANET ==========
            const PLANET_RADIUS = 50;
            const planetGroup = new THREE.Group();
            scene.add(planetGroup);

            // Optimized resolution: 320x320 for smooth performance while maintaining quality
            const planetGeometry = new THREE.SphereGeometry(PLANET_RADIUS, 320, 320);
            const positions = planetGeometry.attributes.position;
            const colors = new Float32Array(positions.count * 3);

            // Terrain generation functions - Improved 3D Perlin-style noise
            function hash3D(x, y, z) {
                // Improved 3D hash function with better distribution
                // Use multiple prime numbers and mixing to avoid patterns
                x = (x * 374761393) & 0x7FFFFFFF;
                x = (x ^ 668265263) & 0x7FFFFFFF;
                y = (y * 668265263) & 0x7FFFFFFF;
                y = (y ^ 374761393) & 0x7FFFFFFF;
                z = (z * 1274126177) & 0x7FFFFFFF;
                z = (z ^ 1453994497) & 0x7FFFFFFF;

                let n = (x * 1453994497 + y * 374761393 + z * 668265263) & 0x7FFFFFFF;
                n = (n ^ (n >> 13)) * 1274126177;
                n = (n ^ (n >> 16));

                return (n & 0x7FFFFFFF) / 0x7FFFFFFF;
            }

            function smoothstep(t) {
                return t * t * (3.0 - 2.0 * t);
            }

            function noise3D(x, y, z) {
                // 3D Perlin-style noise
                const ix = Math.floor(x);
                const iy = Math.floor(y);
                const iz = Math.floor(z);

                const fx = x - ix;
                const fy = y - iy;
                const fz = z - iz;

                const ux = smoothstep(fx);
                const uy = smoothstep(fy);
                const uz = smoothstep(fz);

                // Get random values at cube corners
                const n000 = hash3D(ix, iy, iz);
                const n100 = hash3D(ix + 1, iy, iz);
                const n010 = hash3D(ix, iy + 1, iz);
                const n110 = hash3D(ix + 1, iy + 1, iz);
                const n001 = hash3D(ix, iy, iz + 1);
                const n101 = hash3D(ix + 1, iy, iz + 1);
                const n011 = hash3D(ix, iy + 1, iz + 1);
                const n111 = hash3D(ix + 1, iy + 1, iz + 1);

                // Trilinear interpolation
                const x00 = n000 * (1 - ux) + n100 * ux;
                const x10 = n010 * (1 - ux) + n110 * ux;
                const x01 = n001 * (1 - ux) + n101 * ux;
                const x11 = n011 * (1 - ux) + n111 * ux;

                const y0 = x00 * (1 - uy) + x10 * uy;
                const y1 = x01 * (1 - uy) + x11 * uy;

                return (y0 * (1 - uz) + y1 * uz) * 2 - 1; // Scale to -1 to 1
            }

            function fbm(x, y, z, octaves) {
                // Fractional Brownian Motion for layered noise
                let value = 0;
                let amplitude = 1;
                let frequency = 1;
                let maxValue = 0;

                for (let i = 0; i < octaves; i++) {
                    value += noise3D(x * frequency, y * frequency, z * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2.0;
                }

                return value / maxValue;
            }

            function getTerrainHeight(nx, ny, nz) {
                // Add slight rotation offsets to each noise layer to eliminate seams
                // Use different offsets for each layer
                const continentNoise = fbm(
                    nx * 1.2 + 0.73,
                    ny * 1.2 + 1.17,
                    nz * 1.2 + 2.31,
                    4
                ) * 7;

                const mountainNoise = fbm(
                    nx * 3.5 + 3.41,
                    ny * 3.5 + 5.67,
                    nz * 3.5 + 7.89,
                    3
                ) * 4;

                const detailNoise = fbm(
                    nx * 12 + 11.23,
                    ny * 12 + 13.47,
                    nz * 12 + 17.59,
                    2
                ) * 0.8;

                // Add ridges for mountain ranges with offset
                const ridgeNoise = Math.abs(noise3D(
                    nx * 2.5 + 19.37,
                    ny * 2.5 + 23.41,
                    nz * 2.5 + 29.53
                )) * 2;

                return continentNoise + mountainNoise + detailNoise - ridgeNoise;
            }

            function getBiomeColor(height, latitude, nx, ny, nz) {
                const absLat = Math.abs(latitude);

                // Add texture variation using high-frequency noise with offset
                const textureNoise = noise3D(
                    nx * 25 + 31.41,
                    ny * 25 + 37.53,
                    nz * 25 + 41.67
                ) * 0.12;

                // Helper function for smooth color interpolation
                function lerpColor(c1, c2, t) {
                    return new THREE.Color(
                        c1.r + (c2.r - c1.r) * t,
                        c1.g + (c2.g - c1.g) * t,
                        c1.b + (c2.b - c1.b) * t
                    );
                }

                // Define biome colors
                const deepOcean = new THREE.Color(0x001a3a);
                const ocean = new THREE.Color(0x0d4a7a);
                const beach = new THREE.Color(0xe8d4a0);
                const grassland = new THREE.Color(0x6b8e23);
                const temperateForest = new THREE.Color(0x567d46);
                const tundra = new THREE.Color(0x708090);
                const forest = new THREE.Color(0x2d5016);
                const brownMountain = new THREE.Color(0x8b7355);
                const rockMountain = new THREE.Color(0x696969);
                const snow = new THREE.Color(0xf0f8ff);

                let baseColor;

                // Smooth transitions between height levels
                if (height < -2) {
                    baseColor = deepOcean;
                } else if (height < 0) {
                    const t = (height + 2) / 2; // 0 to 1
                    baseColor = lerpColor(deepOcean, ocean, t);
                } else if (height < 0.5) {
                    const t = height / 0.5;
                    baseColor = lerpColor(ocean, beach, t);
                } else if (height < 2) {
                    const t = (height - 0.5) / 1.5;
                    let targetColor;
                    if (absLat > 0.7) {
                        targetColor = tundra;
                    } else if (absLat > 0.4) {
                        targetColor = temperateForest;
                    } else {
                        targetColor = grassland;
                    }
                    baseColor = lerpColor(beach, targetColor, t);
                } else if (height < 5) {
                    const t = (height - 2) / 3;
                    let lowColor = absLat > 0.4 ? temperateForest : grassland;
                    let highColor = absLat > 0.6 ? brownMountain : forest;
                    baseColor = lerpColor(lowColor, highColor, t);
                } else if (height < 8) {
                    const t = (height - 5) / 3;
                    baseColor = lerpColor(brownMountain, rockMountain, t);
                } else {
                    const t = Math.min((height - 8) / 2, 1);
                    baseColor = lerpColor(rockMountain, snow, t);
                }

                // Apply texture variation
                baseColor.r = Math.max(0, Math.min(1, baseColor.r + textureNoise));
                baseColor.g = Math.max(0, Math.min(1, baseColor.g + textureNoise));
                baseColor.b = Math.max(0, Math.min(1, baseColor.b + textureNoise));

                return baseColor;
            }

            // Generate terrain
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);

                const len = Math.sqrt(x * x + y * y + z * z);
                const nx = x / len, ny = y / len, nz = z / len;

                const height = getTerrainHeight(nx, ny, nz);
                const latitude = Math.asin(ny);
                const color = getBiomeColor(height, latitude, nx, ny, nz);

                positions.setXYZ(i, nx * (PLANET_RADIUS + height), ny * (PLANET_RADIUS + height), nz * (PLANET_RADIUS + height));
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }

            planetGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            planetGeometry.computeVertexNormals();

            const planet = new THREE.Mesh(planetGeometry, new THREE.MeshStandardMaterial({
                vertexColors: true,
                roughness: 0.85,
                metalness: 0.05,
                flatShading: false // Ensure smooth shading for better terrain look
            }));
            planet.castShadow = true;
            planet.receiveShadow = true;
            planetGroup.add(planet);

            // Atmosphere (reduced resolution for better performance)
            const atmoGeo = new THREE.SphereGeometry(PLANET_RADIUS + 5, 32, 32);
            const atmoMat = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vNormal;
                    void main() {
                        float intensity = pow(0.5 - dot(vNormal, vec3(0, 0, 1.0)), 3.0);
                        gl_FragColor = vec4(0.4, 0.6, 1.0, 1.0) * intensity * 2.5;
                    }
                `,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                transparent: true
            });
            planetGroup.add(new THREE.Mesh(atmoGeo, atmoMat));

            // ========== RAYCASTER FOR TERRAIN HEIGHT WITH CACHE ==========
            const terrainRaycaster = new THREE.Raycaster();
            const terrainHeightCache = new Map();
            const CACHE_GRID_SIZE = 64; // Grid resolution for caching

            function getCacheKey(nx, ny, nz) {
                // Quantize normalized coordinates to grid
                const gx = Math.round(nx * CACHE_GRID_SIZE);
                const gy = Math.round(ny * CACHE_GRID_SIZE);
                const gz = Math.round(nz * CACHE_GRID_SIZE);
                return `${gx},${gy},${gz}`;
            }

            function getTerrainHeightAtPosition(position) {
                const normalized = position.clone().normalize();
                const cacheKey = getCacheKey(normalized.x, normalized.y, normalized.z);

                // Check cache first
                if (terrainHeightCache.has(cacheKey)) {
                    return terrainHeightCache.get(cacheKey);
                }

                // Calculate using procedural method (faster than raycasting)
                const height = getTerrainHeight(normalized.x, normalized.y, normalized.z);

                // Store in cache
                terrainHeightCache.set(cacheKey, height);

                // Limit cache size to prevent memory issues
                if (terrainHeightCache.size > 10000) {
                    const firstKey = terrainHeightCache.keys().next().value;
                    terrainHeightCache.delete(firstKey);
                }

                return height;
            }

            // ========== ORGANISMS ==========
            class Brain {
                constructor(complexity = 1) {
                    this.weights = Array(20 * complexity).fill(0).map(() => Math.random() * 2 - 1);
                }

                think(inputs) {
                    const sum = inputs.reduce((s, input, i) => s + input * this.weights[i % this.weights.length], 0);
                    return Math.tanh(sum);
                }

                clone() {
                    const b = new Brain();
                    b.weights = [...this.weights];
                    return b;
                }

                mutate() {
                    const i = Math.floor(Math.random() * this.weights.length);
                    this.weights[i] += (Math.random() - 0.5) * 0.4;
                }
            }

            let orgId = 0;
            const organisms = [];
            let selected = null;

            class Organism {
                constructor(type, pos) {
                    this.id = orgId++;
                    this.type = type;
                    this.position = pos.clone();
                    this.velocity = new THREE.Vector3();
                    this.age = 0;
                    this.energy = 100;
                    this.health = 100;
                    this.generation = 1;
                    this.brain = type !== 'plant' ? new Brain(type === 'humanoid' ? 2 : 1) : null;
                    this.dead = false;
                    this.deathTime = 0; // Track time since death for decay
                    // Randomize initial timer to prevent synchronized reproduction
                    this.reproduceTimer = Math.random() * 50;

                    const sizes = { plant: 2.5, herbivore: 2, carnivore: 2.5, humanoid: 3 };
                    const speeds = { plant: 0, herbivore: 0.18, carnivore: 0.22, humanoid: 0.15 };

                    this.size = sizes[type];
                    this.speed = speeds[type];

                    this.createMesh();
                }

                createMesh() {
                    const group = new THREE.Group();

                    if (this.type === 'plant') {
                        const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, this.size * 0.8, 8);
                        const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.9 });
                        const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                        trunk.position.y = this.size * 0.4;
                        trunk.castShadow = true;
                        group.add(trunk);

                        const canopyGeo = new THREE.SphereGeometry(this.size * 0.6, 8, 8);
                        const canopyMat = new THREE.MeshStandardMaterial({
                            color: 0x2d5016,
                            emissive: 0x1a3010,
                            emissiveIntensity: 0.3,
                            roughness: 0.7
                        });
                        const canopy = new THREE.Mesh(canopyGeo, canopyMat);
                        canopy.position.y = this.size * 1.2;
                        canopy.scale.set(1, 1.2, 1);
                        canopy.castShadow = true;
                        group.add(canopy);

                    } else if (this.type === 'herbivore') {
                        const bodyGeo = new THREE.BoxGeometry(this.size, this.size * 0.6, this.size * 1.2);
                        const bodyMat = new THREE.MeshStandardMaterial({
                            color: 0x8b6914,
                            emissive: 0x443509,
                            emissiveIntensity: 0.4,
                            roughness: 0.6
                        });
                        const body = new THREE.Mesh(bodyGeo, bodyMat);
                        body.position.y = this.size * 0.5;
                        body.castShadow = true;
                        group.add(body);

                        const legGeo = new THREE.CylinderGeometry(0.15, 0.15, this.size * 0.5, 6);
                        for (let i = 0; i < 4; i++) {
                            const leg = new THREE.Mesh(legGeo, bodyMat);
                            leg.position.set(
                                i % 2 === 0 ? -this.size * 0.3 : this.size * 0.3,
                                this.size * 0.25,
                                i < 2 ? this.size * 0.4 : -this.size * 0.4
                            );
                            leg.castShadow = true;
                            group.add(leg);
                        }

                    } else if (this.type === 'carnivore') {
                        const bodyGeo = new THREE.ConeGeometry(this.size * 0.7, this.size * 1.5, 8);
                        const bodyMat = new THREE.MeshStandardMaterial({
                            color: 0x8b0000,
                            emissive: 0x450000,
                            emissiveIntensity: 0.5,
                            roughness: 0.5,
                            metalness: 0.2
                        });
                        const body = new THREE.Mesh(bodyGeo, bodyMat);
                        body.position.y = this.size * 0.8;
                        body.rotation.x = Math.PI;
                        body.castShadow = true;
                        group.add(body);

                    } else { // humanoid
                        const bodyGeo = new THREE.BoxGeometry(this.size * 0.6, this.size * 1, this.size * 0.4);
                        const bodyMat = new THREE.MeshStandardMaterial({
                            color: 0xffdbac,
                            emissive: 0x6b5544,
                            emissiveIntensity: 0.3,
                            roughness: 0.7
                        });
                        const body = new THREE.Mesh(bodyGeo, bodyMat);
                        body.position.y = this.size * 0.9;
                        body.castShadow = true;
                        group.add(body);

                        const headGeo = new THREE.SphereGeometry(this.size * 0.3, 8, 8);
                        const head = new THREE.Mesh(headGeo, bodyMat);
                        head.position.y = this.size * 1.6;
                        head.castShadow = true;
                        group.add(head);

                        const legGeo = new THREE.CylinderGeometry(0.15, 0.15, this.size * 0.8, 6);
                        for (let i = 0; i < 2; i++) {
                            const leg = new THREE.Mesh(legGeo, bodyMat);
                            leg.position.set(i === 0 ? -this.size * 0.2 : this.size * 0.2, this.size * 0.4, 0);
                            leg.castShadow = true;
                            group.add(leg);
                        }
                    }

                    group.castShadow = true;
                    group.receiveShadow = true;
                    this.mesh = group;
                    this.mesh.userData.organism = this;
                    this.updateMeshPosition();
                    planetGroup.add(this.mesh);
                }

                updateMeshPosition() {
                    if (!this.mesh) return;

                    const normal = this.position.clone().normalize();

                    // GET ACTUAL TERRAIN HEIGHT
                    const terrainHeight = getTerrainHeightAtPosition(this.position);
                    const distance = PLANET_RADIUS + terrainHeight + (this.type === 'plant' ? 0 : 0.1);

                    this.mesh.position.copy(normal.clone().multiplyScalar(distance));

                    // Orient upright on sphere
                    this.mesh.up.copy(normal);
                    this.mesh.lookAt(this.mesh.position.clone().add(new THREE.Vector3(1, 0, 0)));

                    if (this === selected) {
                        this.mesh.traverse(child => {
                            if (child.material) child.material.emissiveIntensity = 1.5;
                        });
                    } else {
                        this.mesh.traverse(child => {
                            if (child.material && child.material.emissive) {
                                child.material.emissiveIntensity = this.type === 'plant' ? 0.3 : 0.4;
                            }
                        });
                    }
                }

                think(spatialGrid) {
                    if (this.type === 'plant' || !this.brain) return;

                    let nearestFood = null, nearestFoodDist = Infinity;
                    let nearestPredator = null, nearestPredatorDist = Infinity;
                    let nearestPrey = null, nearestPreyDist = Infinity;

                    // Use spatial grid instead of checking all organisms - HUGE performance boost
                    const nearby = spatialGrid.getNearby(this.position);

                    for (const o of nearby) {
                        if (o === this || o.dead) continue;
                        const dist = this.position.distanceTo(o.position);

                        if (this.type === 'herbivore' || this.type === 'humanoid') {
                            if (o.type === 'plant' && dist < nearestFoodDist) {
                                nearestFood = o;
                                nearestFoodDist = dist;
                            }
                            if (o.type === 'carnivore' && dist < nearestPredatorDist) {
                                nearestPredator = o;
                                nearestPredatorDist = dist;
                            }
                        }

                        if (this.type === 'carnivore') {
                            if ((o.type === 'herbivore' || o.type === 'humanoid') && dist < nearestPreyDist) {
                                nearestPrey = o;
                                nearestPreyDist = dist;
                            }
                        }
                    }

                    const inputs = [
                        this.energy / 100,
                        this.health / 100,
                        1 - Math.min(nearestFoodDist / 40, 1),
                        1 - Math.min(nearestPredatorDist / 40, 1),
                        1 - Math.min(nearestPreyDist / 40, 1)
                    ];

                    const output = this.brain.think(inputs);

                    // FIXED: Actually seek food/prey and flee predators!
                    const normal = this.position.clone().normalize();
                    let targetDirection = new THREE.Vector3();

                    // Decide what to do based on situation
                    const isHungry = this.energy < 70; // Seek food earlier to prevent starvation
                    const inDanger = nearestPredatorDist < 15;

                    if (this.type === 'herbivore' || this.type === 'humanoid') {
                        if (inDanger && nearestPredator) {
                            // FLEE from predator
                            targetDirection.subVectors(this.position, nearestPredator.position);
                        } else if (isHungry && nearestFood) {
                            // SEEK food
                            targetDirection.subVectors(nearestFood.position, this.position);
                        } else {
                            // Wander randomly
                            targetDirection.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                        }
                    } else if (this.type === 'carnivore') {
                        if (isHungry && nearestPrey) {
                            // HUNT prey
                            targetDirection.subVectors(nearestPrey.position, this.position);
                        } else {
                            // Wander randomly
                            targetDirection.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5);
                        }
                    }

                    // Project onto tangent plane and move
                    targetDirection.sub(normal.clone().multiplyScalar(targetDirection.dot(normal)));
                    targetDirection.normalize();

                    this.velocity.copy(targetDirection.multiplyScalar(Math.abs(output) * this.speed));
                }

                update(delta, spatialGrid) {
                    this.age += delta;

                    // Handle decay animation for dead organisms
                    if (this.dead) {
                        this.deathTime += delta;

                        // Decay over 60 time units
                        const decayProgress = Math.min(this.deathTime / 60, 1);

                        if (this.mesh) {
                            // Fade out: from 0.5 to 0
                            const opacity = 0.5 * (1 - decayProgress);

                            // Sink into ground and shrink
                            const sinkAmount = decayProgress * 2; // Sink 2 units
                            const shrinkScale = 1 - decayProgress * 0.7; // Shrink to 30% of size

                            this.mesh.traverse(child => {
                                if (child.material) {
                                    child.material.opacity = opacity;
                                }
                            });

                            this.mesh.scale.setScalar(shrinkScale);

                            // Update position to sink into ground
                            const normal = this.position.clone().normalize();
                            const terrainHeight = getTerrainHeightAtPosition(this.position);
                            const distance = PLANET_RADIUS + terrainHeight + (this.type === 'plant' ? 0 : 0.1) - sinkAmount;
                            this.mesh.position.copy(normal.clone().multiplyScalar(distance));
                        }

                        return; // Don't process living organism logic
                    }

                    // Living organism logic
                    // Reduced base energy drain for better survival
                    this.energy -= delta * 0.15; // Was 0.35, now 0.15
                    this.reproduceTimer += delta;

                    if (this.type !== 'plant') {
                        this.think(spatialGrid);
                        this.position.add(this.velocity);
                        this.position.normalize().multiplyScalar(PLANET_RADIUS);
                        // Reduced movement cost for better survival
                        this.energy -= this.velocity.length() * 0.6; // Was 1.2, now 0.6
                    } else {
                        // Increased plant energy gain for faster reproduction
                        this.energy += delta * 0.8; // Was 0.5, now 0.8
                        this.energy = Math.min(this.energy, 100);
                    }

                    // Increased max age for longer lifespans (was 500, now 800)
                    if (this.energy <= 0 || this.health <= 0 || this.age > 800) {
                        this.die();
                    }

                    this.updateMeshPosition();
                }

                eat(food) {
                    // Increased food energy for better survival (was 45, now 65)
                    this.energy += 65;
                    this.energy = Math.min(this.energy, 100);
                    food.die();
                }

                die() {
                    this.dead = true;
                    this.deathTime = 0; // Start decay timer
                    if (this.mesh) {
                        this.mesh.traverse(child => {
                            if (child.material) {
                                child.material.transparent = true;
                                // Start at semi-transparent gray
                                child.material.opacity = 0.5;
                                const grayColor = new THREE.Color(0x666666);
                                if (child.material.emissive) {
                                    child.material.emissive.copy(grayColor);
                                    child.material.emissiveIntensity = 0.1;
                                }
                            }
                        });
                    }
                }

                canReproduce() {
                    // Different requirements for plants vs animals
                    if (this.type === 'plant') {
                        // Plants reproduce faster to sustain ecosystem
                        return !this.dead && this.energy > 60 && this.reproduceTimer > 25;
                    } else {
                        // Animals need more energy to reproduce (was energy>80, health>60, timer>50)
                        return !this.dead && this.energy > 70 && this.health > 50 && this.reproduceTimer > 40;
                    }
                }

                reproduce() {
                    // Different costs for plants vs animals
                    if (this.type === 'plant') {
                        this.energy -= 20; // Lower cost for plants
                    } else {
                        this.energy -= 30; // Higher cost for animals (was 40, now 30)
                    }
                    this.reproduceTimer = 0;

                    const childBrain = this.brain ? this.brain.clone() : null;
                    if (childBrain) childBrain.mutate();

                    const offset = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).multiplyScalar(4);

                    const child = new Organism(this.type, this.position.clone().add(offset));
                    child.generation = this.generation + 1;
                    child.brain = childBrain;

                    return child;
                }
            }

            function spawnOrganism(type, count = 1) {
                for (let i = 0; i < count; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    const pos = new THREE.Vector3(
                        Math.sin(phi) * Math.cos(theta),
                        Math.cos(phi),
                        Math.sin(phi) * Math.sin(theta)
                    ).multiplyScalar(PLANET_RADIUS);

                    organisms.push(new Organism(type, pos));
                }
            }

            // Spatial grid for collision optimization
            class SpatialGrid {
                constructor(cellSize) {
                    this.cellSize = cellSize;
                    this.grid = new Map();
                }

                clear() {
                    this.grid.clear();
                }

                getCellKey(position) {
                    const x = Math.floor(position.x / this.cellSize);
                    const y = Math.floor(position.y / this.cellSize);
                    const z = Math.floor(position.z / this.cellSize);
                    return `${x},${y},${z}`;
                }

                add(organism) {
                    const key = this.getCellKey(organism.position);
                    if (!this.grid.has(key)) {
                        this.grid.set(key, []);
                    }
                    this.grid.get(key).push(organism);
                }

                getNearby(position) {
                    const x = Math.floor(position.x / this.cellSize);
                    const y = Math.floor(position.y / this.cellSize);
                    const z = Math.floor(position.z / this.cellSize);
                    const nearby = [];

                    // Check current cell and 26 neighboring cells
                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dz = -1; dz <= 1; dz++) {
                                const key = `${x + dx},${y + dy},${z + dz}`;
                                if (this.grid.has(key)) {
                                    nearby.push(...this.grid.get(key));
                                }
                            }
                        }
                    }
                    return nearby;
                }
            }

            const spatialGrid = new SpatialGrid(20); // 20 unit cells for better food detection

            function updateEcosystem(delta) {
                // Build spatial grid FIRST for both thinking and collision detection
                spatialGrid.clear();
                for (const o of organisms) {
                    if (!o.dead) spatialGrid.add(o);
                }

                // Update all organisms (now using spatial grid for thinking)
                for (const o of organisms) o.update(delta, spatialGrid);

                // Collision detection using spatial grid (much faster than O(n¬≤))
                for (const o of organisms) {
                    if (o.dead) continue;

                    if (o.type === 'herbivore' || o.type === 'humanoid') {
                        const nearby = spatialGrid.getNearby(o.position);
                        for (const other of nearby) {
                            if (other.type === 'plant' && !other.dead && o.position.distanceTo(other.position) < 4) {
                                o.eat(other);
                                break;
                            }
                        }
                    }

                    if (o.type === 'carnivore') {
                        const nearby = spatialGrid.getNearby(o.position);
                        for (const other of nearby) {
                            if ((other.type === 'herbivore' || other.type === 'humanoid') &&
                                !other.dead && o.position.distanceTo(other.position) < 4) {
                                o.eat(other);
                                break;
                            }
                        }
                    }
                }

                // God mode effects on organisms
                for (const o of organisms) {
                    if (o.dead) continue;

                    // Plague damage
                    if (o.plagued && o.plagueTimer > 0) {
                        o.health -= delta * 0.5;
                        o.plagueTimer -= delta;
                        if (o.plagueTimer <= 0) {
                            o.plagued = false;
                        }
                    }

                    // Food surplus boost
                    if (godMode.foodSurplusActive && o.type === 'plant') {
                        o.energy += delta * 0.4; // Extra boost
                        o.energy = Math.min(100, o.energy);
                    }

                    // Famine drain
                    if (godMode.famineActive && o.type === 'plant') {
                        o.energy -= delta * 0.6; // Extra drain
                    }
                }

                // Update god mode timers
                if (godMode.foodSurplusActive) {
                    godMode.foodSurplusTimer -= delta;
                    if (godMode.foodSurplusTimer <= 0) {
                        godMode.foodSurplusActive = false;
                        showNotification('üåæ Food surplus ended');
                    }
                }

                if (godMode.famineActive) {
                    godMode.famineTimer -= delta;
                    if (godMode.famineTimer <= 0) {
                        godMode.famineActive = false;
                        showNotification('ü•Ä Famine ended');
                    }
                }

                // Reproduction (with population cap for performance)
                const MAX_ORGANISMS = 200; // Prevent lag from too many organisms
                for (const o of organisms) {
                    if (organisms.length >= MAX_ORGANISMS) break;
                    if (o.canReproduce()) {
                        organisms.push(o.reproduce());
                    }
                }

                // Cleanup fully decayed organisms
                for (let i = organisms.length - 1; i >= 0; i--) {
                    // Remove after 65 time units of being dead (decay finishes at 60)
                    if (organisms[i].dead && organisms[i].deathTime > 65) {
                        if (organisms[i].mesh) planetGroup.remove(organisms[i].mesh);
                        if (selected === organisms[i]) {
                            selected = null;
                            document.getElementById('creature-detail').classList.remove('show');
                        }
                        organisms.splice(i, 1);
                    }
                }
            }

            // Population tracking
            const popHistory = { time: [], plants: [], herbivores: [], carnivores: [], humanoids: [] };
            const MAX_HISTORY = 100;

            function updatePopHistory() {
                const simTime = Math.floor(state.time);
                if (simTime % 2 === 0 && (popHistory.time.length === 0 || popHistory.time[popHistory.time.length - 1] !== simTime)) {
                    popHistory.time.push(simTime);
                    // Use cached counts instead of filtering entire array
                    popHistory.plants.push(cachedCounts.plant);
                    popHistory.herbivores.push(cachedCounts.herbivore);
                    popHistory.carnivores.push(cachedCounts.carnivore);
                    popHistory.humanoids.push(cachedCounts.humanoid);

                    if (popHistory.time.length > MAX_HISTORY) {
                        popHistory.time.shift();
                        popHistory.plants.shift();
                        popHistory.herbivores.shift();
                        popHistory.carnivores.shift();
                        popHistory.humanoids.shift();
                    }

                    if (window.popChart) {
                        window.popChart.data.labels = popHistory.time;
                        window.popChart.data.datasets[0].data = popHistory.plants;
                        window.popChart.data.datasets[1].data = popHistory.herbivores;
                        window.popChart.data.datasets[2].data = popHistory.carnivores;
                        window.popChart.data.datasets[3].data = popHistory.humanoids;
                        window.popChart.update('none');
                    }
                }
            }

            // Camera
            let cameraAngle = 0, cameraDistance = 140, cameraHeight = 60;
            let isDragging = false, prevX = 0, prevY = 0;

            renderer.domElement.addEventListener('mousedown', e => {
                isDragging = true;
                prevX = e.clientX;
                prevY = e.clientY;
            });

            renderer.domElement.addEventListener('mousemove', e => {
                if (isDragging) {
                    cameraAngle += (e.clientX - prevX) * 0.005;
                    cameraHeight -= (e.clientY - prevY) * 0.5;
                    cameraHeight = Math.max(-80, Math.min(100, cameraHeight));
                    prevX = e.clientX;
                    prevY = e.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => isDragging = false);

            renderer.domElement.addEventListener('wheel', e => {
                e.preventDefault();
                cameraDistance += e.deltaY * 0.1;
                cameraDistance = Math.max(80, Math.min(250, cameraDistance));
            });

            // Touch controls for mobile
            let touches = [];
            let lastPinchDistance = 0;

            renderer.domElement.addEventListener('touchstart', e => {
                touches = Array.from(e.touches);
                if (touches.length === 1) {
                    isDragging = true;
                    prevX = touches[0].clientX;
                    prevY = touches[0].clientY;
                } else if (touches.length === 2) {
                    isDragging = false;
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    lastPinchDistance = Math.sqrt(dx * dx + dy * dy);
                }
            });

            renderer.domElement.addEventListener('touchmove', e => {
                e.preventDefault();
                touches = Array.from(e.touches);

                if (touches.length === 1 && isDragging) {
                    // Single finger drag - rotate camera
                    cameraAngle += (touches[0].clientX - prevX) * 0.005;
                    cameraHeight -= (touches[0].clientY - prevY) * 0.5;
                    cameraHeight = Math.max(-80, Math.min(100, cameraHeight));
                    prevX = touches[0].clientX;
                    prevY = touches[0].clientY;
                } else if (touches.length === 2) {
                    // Two finger pinch - zoom
                    const dx = touches[0].clientX - touches[1].clientX;
                    const dy = touches[0].clientY - touches[1].clientY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const delta = distance - lastPinchDistance;
                    cameraDistance -= delta * 0.5;
                    cameraDistance = Math.max(80, Math.min(250, cameraDistance));
                    lastPinchDistance = distance;
                }
            }, { passive: false });

            renderer.domElement.addEventListener('touchend', () => {
                isDragging = false;
                touches = [];
            });

            // Click selection
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            renderer.domElement.addEventListener('click', e => {
                if (isDragging) return;

                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(planetGroup.children, true);

                // Check for active god power
                if (godMode.activePower && POWERS[godMode.activePower]) {
                    const power = POWERS[godMode.activePower];

                    // Global powers (don't need targeting)
                    if (power.targetType === 'global') {
                        power.execute();
                        return;
                    }

                    // Find target based on power type
                    if (power.targetType === 'creature' || power.targetType === 'dead-creature') {
                        for (const hit of intersects) {
                            if (hit.object.parent && hit.object.parent.userData.organism) {
                                const organism = hit.object.parent.userData.organism;
                                if (power.targetType === 'creature' && !organism.dead) {
                                    power.execute(organism);
                                    return;
                                } else if (power.targetType === 'dead-creature' && organism.dead) {
                                    power.execute(organism);
                                    return;
                                }
                            }
                        }
                    }

                    // Location or terraform powers (click on planet surface)
                    if (power.targetType === 'location' || power.targetType === 'terraform') {
                        // Raycast to planet surface
                        const planetHits = raycaster.intersectObject(planetGroup.children[0]); // First child is planet mesh
                        if (planetHits.length > 0) {
                            power.execute(planetHits[0].point);
                            return;
                        }
                    }

                    return; // Power active but no valid target clicked
                }

                // Normal creature selection (no power active)
                for (const hit of intersects) {
                    if (hit.object.parent && hit.object.parent.userData.organism) {
                        selected = hit.object.parent.userData.organism;
                        updateCreatureDetail();
                        break;
                    }
                }
            });

            function updateCreatureList() {
                const list = document.getElementById('creature-list');
                const searchTerm = document.getElementById('search-input').value.toLowerCase();
                const activeFilter = document.querySelector('.filter-btn.active[data-filter]');
                const filter = activeFilter ? activeFilter.dataset.filter : 'all';

                let filtered = organisms.filter(o => !o.dead);

                if (filter !== 'all') {
                    filtered = filtered.filter(o => o.type === filter);
                }

                if (searchTerm) {
                    filtered = filtered.filter(o =>
                        o.type.includes(searchTerm) ||
                        o.id.toString().includes(searchTerm)
                    );
                }

                filtered = filtered.slice(0, 50);

                const icons = { plant: 'üå≥', herbivore: 'ü¶å', carnivore: 'ü¶Å', humanoid: 'üë§' };

                list.innerHTML = filtered.map(o => `
                    <div class="creature-item ${o === selected ? 'selected' : ''}" data-id="${o.id}">
                        <div class="creature-name">${icons[o.type]} ${o.type.toUpperCase()} #${o.id}</div>
                        <div class="creature-type">Gen ${o.generation} ‚Ä¢ Age ${Math.floor(o.age)}s</div>
                        <div class="creature-stats">
                            <span>E:${Math.floor(o.energy)}</span>
                            <span>H:${Math.floor(o.health)}</span>
                        </div>
                    </div>
                `).join('') || '<div style="opacity: 0.5; text-align: center; padding: 1rem;">No creatures found</div>';

                list.querySelectorAll('.creature-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const id = parseInt(item.dataset.id);
                        const organism = organisms.find(o => o.id === id);
                        if (organism) {
                            selected = organism;
                            updateCreatureDetail();
                            updateCreatureList();
                        }
                    });
                });
            }

            function updateCreatureDetail() {
                if (!selected || selected.dead) {
                    document.getElementById('creature-detail').classList.remove('show');
                    return;
                }

                document.getElementById('creature-detail').classList.add('show');
                const icons = { plant: 'üå≥', herbivore: 'ü¶å', carnivore: 'ü¶Å', humanoid: 'üë§' };
                document.getElementById('creature-info').innerHTML = `
                    <div style="margin-bottom: 0.8rem; font-size: 1.2rem; color: var(--text-bright);">
                        ${icons[selected.type]} ${selected.type.toUpperCase()} #${selected.id}
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Generation</span>
                        <span class="stat-value">${selected.generation}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Age</span>
                        <span class="stat-value">${Math.floor(selected.age)}s</span>
                    </div>
                    <div style="margin: 0.8rem 0;">
                        <div style="font-size: 0.75rem; margin-bottom: 0.3rem; color: var(--text-dim);">HEALTH</div>
                        <div class="progress-bar">
                            <div class="progress-fill health" style="width: ${selected.health}%"></div>
                        </div>
                        <div style="font-size: 0.75rem; margin: 0.5rem 0 0.3rem; color: var(--text-dim);">ENERGY</div>
                        <div class="progress-bar">
                            <div class="progress-fill energy" style="width: ${selected.energy}%"></div>
                        </div>
                    </div>
                    ${selected.brain ? `
                    <div class="stat-row">
                        <span class="stat-label">Neural Network</span>
                        <span class="stat-value">${selected.brain.weights.length} weights</span>
                    </div>` : ''}
                `;
            }

            // Cached organism counts for performance
            let cachedCounts = { plant: 0, herbivore: 0, carnivore: 0, humanoid: 0 };
            let uiUpdateCounter = 0;
            const UI_UPDATE_INTERVAL = 5; // Update UI every 5 frames instead of every frame

            function updateOrganismCounts() {
                cachedCounts = { plant: 0, herbivore: 0, carnivore: 0, humanoid: 0 };
                for (const o of organisms) {
                    if (!o.dead) cachedCounts[o.type]++;
                }
            }

            function updateUI() {
                uiUpdateCounter++;

                // Update counts every N frames (or on first frame)
                if (uiUpdateCounter === 1 || uiUpdateCounter % UI_UPDATE_INTERVAL === 0) {
                    updateOrganismCounts();
                    document.getElementById('plant-count').textContent = cachedCounts.plant;
                    document.getElementById('herbivore-count').textContent = cachedCounts.herbivore;
                    document.getElementById('carnivore-count').textContent = cachedCounts.carnivore;
                    document.getElementById('humanoid-count').textContent = cachedCounts.humanoid;

                    // Achievement checks
                    const totalLiving = Object.values(cachedCounts).reduce((a, b) => a + b, 0);
                    if (totalLiving >= 100) checkAchievement('hundredCreatures');
                    if (totalLiving === 0 && organisms.length > 0) checkAchievement('extinction');
                    if (organisms.length > 0) checkAchievement('firstCreature');

                    // Check max generation
                    const maxGen = Math.max(...organisms.map(o => o.generation));
                    if (maxGen >= 100) checkAchievement('evolution100');
                }

                document.getElementById('day-count').textContent = Math.floor(state.time / 60);

                // Throttle creature list updates (or on first frame)
                if (uiUpdateCounter === 1 || uiUpdateCounter % 30 === 0) { // Every 30 frames
                    updateCreatureList();
                }

                if (selected && !selected.dead) {
                    updateCreatureDetail();
                }

                // Throttle chart updates (or on first frame)
                if (uiUpdateCounter === 1 || uiUpdateCounter % 10 === 0) {
                    updatePopHistory();
                }
            }

            const state = {
                time: 0,
                paused: false,
                speed: 1,
                dayTime: 0, // 0 to 1, represents time of day (0 = midnight, 0.5 = noon)
                dayNightSpeed: 0.01, // How fast day cycles (1 = full cycle per second)
                lastAutoSave: 0 // Track last auto-save time
            };

            // ========== GOD MODE SYSTEM ==========
            const godMode = {
                enabled: true,
                activePower: null,
                settings: {
                    brushSize: 10,
                    effectRadius: 15,
                    spawnCount: 50,
                    terraformStrength: 2
                },
                foodSurplusActive: false,
                foodSurplusTimer: 0,
                famineActive: false,
                famineTimer: 0
            };

            // Store recently dead organisms for resurrection (keep last 50)
            const recentlyDead = [];

            // Active particle effects
            const activeEffects = [];

            // ========== ACHIEVEMENT SYSTEM ==========
            const achievements = {
                firstCreature: { name: 'üå± First Life', desc: 'Spawn your first creature', unlocked: false },
                hundredCreatures: { name: 'üåø Thriving World', desc: 'Have 100+ organisms alive', unlocked: false },
                extinction: { name: 'üíÄ Extinction Event', desc: 'Kill all organisms', unlocked: false },
                godOfLife: { name: '‚ú® God of Life', desc: 'Use Resurrect power', unlocked: false },
                meteorStrike: { name: '‚òÑÔ∏è Divine Wrath', desc: 'Use Meteor Strike', unlocked: false },
                evolution100: { name: 'üß¨ Evolution Master', desc: 'Reach generation 100', unlocked: false },
                balance: { name: '‚öñÔ∏è Perfect Balance', desc: 'Balance the ecosystem', unlocked: false },
                nightOwl: { name: 'üåô Night Owl', desc: 'Witness the night', unlocked: false },
                sunrise: { name: 'üåÖ New Dawn', desc: 'See the sunrise', unlocked: false },
                terraform: { name: 'üèîÔ∏è World Shaper', desc: 'Terraform terrain', unlocked: false }
            };

            function checkAchievement(key) {
                if (!achievements[key].unlocked) {
                    achievements[key].unlocked = true;
                    showNotification(`üèÜ Achievement: ${achievements[key].name}`);
                    playSound(1200, 200);
                }
            }

            // Power Definitions
            const POWERS = {
                'bless': {
                    name: 'Bless',
                    targetType: 'creature',
                    execute: (organism) => {
                        organism.energy = Math.min(100, organism.energy + 50);
                        organism.health = Math.min(100, organism.health + 50);
                        createGlowEffect(organism, 0xFFD700, 2000);
                        showNotification(`‚ú® Blessed ${organism.type} #${organism.id}`);
                    }
                },
                'curse': {
                    name: 'Curse',
                    targetType: 'creature',
                    execute: (organism) => {
                        organism.energy = Math.max(0, organism.energy - 50);
                        organism.health = Math.max(10, organism.health - 50);
                        createGlowEffect(organism, 0x800080, 2000);
                        showNotification(`üíÄ Cursed ${organism.type} #${organism.id}`);
                    }
                },
                'smite': {
                    name: 'Smite',
                    targetType: 'creature',
                    execute: (organism) => {
                        // Lightning strike from above
                        const skyPos = organism.position.clone().normalize().multiplyScalar(PLANET_RADIUS + 30);
                        createLightningEffect(skyPos, organism.position);
                        organism.die();
                        showNotification(`‚ö° Smited ${organism.type} #${organism.id}`);
                        playSound(200, 300);
                    }
                },
                'resurrect': {
                    name: 'Resurrect',
                    targetType: 'dead-creature',
                    execute: (organism) => {
                        organism.dead = false;
                        organism.deathTime = 0;
                        organism.energy = 100;
                        organism.health = 100;
                        organism.age = 0;
                        if (organism.mesh) {
                            organism.mesh.traverse(child => {
                                if (child.material) {
                                    child.material.opacity = 1;
                                    child.material.transparent = false;
                                }
                            });
                            organism.mesh.scale.setScalar(1);
                        }
                        createGlowEffect(organism, 0x00FFFF, 2000);
                        showNotification(`üåü Resurrected ${organism.type} #${organism.id}`);
                        checkAchievement('godOfLife');
                    }
                },
                'evolve': {
                    name: 'Evolve',
                    targetType: 'creature',
                    execute: (organism) => {
                        if (organism.brain) {
                            for (let i = 0; i < 5; i++) organism.brain.mutate();
                            organism.generation += 5;
                            createEvolutionEffect(organism.position);
                            showNotification(`üß¨ Evolved ${organism.type} #${organism.id} to gen ${organism.generation}`);
                            playSound(800, 200);
                        }
                    }
                },
                'clone': {
                    name: 'Clone',
                    targetType: 'creature',
                    execute: (organism) => {
                        const offset = new THREE.Vector3(2, 0, 0);
                        const clonePos = organism.position.clone().add(offset);
                        const clone = new Organism(organism.type, clonePos);
                        clone.generation = organism.generation;
                        clone.brain = organism.brain ? organism.brain.clone() : null;
                        organisms.push(clone);
                        createGlowEffect(organism, 0x00FFFF, 1500);
                        createGlowEffect(clone, 0x00FFFF, 1500);
                        showNotification(`üë• Cloned ${organism.type} #${organism.id}`);
                    }
                },
                'boost-iq': {
                    name: 'Boost IQ',
                    targetType: 'creature',
                    execute: (organism) => {
                        if (organism.brain) {
                            organism.brain.weights = [...organism.brain.weights, ...organism.brain.weights];
                            createGlowEffect(organism, 0x0088FF, 2000);
                            showNotification(`üß† Boosted intelligence of ${organism.type} #${organism.id}`);
                        }
                    }
                },
                'meteor': {
                    name: 'Meteor',
                    targetType: 'location',
                    execute: (position) => {
                        // Dramatic explosion effect
                        createExplosionEffect(position, 0xFF4400);
                        const radius = godMode.settings.effectRadius;
                        let killed = 0;
                        for (const o of organisms) {
                            if (!o.dead && o.position.distanceTo(position) < radius) {
                                o.die();
                                killed++;
                            }
                        }
                        showNotification(`‚òÑÔ∏è Meteor strike! Killed ${killed} organisms`);
                        playSound(100, 500);
                        checkAchievement('meteorStrike');
                    }
                },
                'lightning': {
                    name: 'Lightning',
                    targetType: 'creature',
                    execute: (organism) => {
                        const skyPos = organism.position.clone().normalize().multiplyScalar(PLANET_RADIUS + 30);
                        createLightningEffect(skyPos, organism.position);
                        organism.die();
                        showNotification(`‚ö° Lightning struck ${organism.type} #${organism.id}`);
                        playSound(150, 250);
                    }
                },
                'plague': {
                    name: 'Plague',
                    targetType: 'location',
                    execute: (position) => {
                        createPlagueCloud(position);
                        const radius = godMode.settings.effectRadius;
                        let infected = 0;
                        for (const o of organisms) {
                            if (!o.dead && o.type !== 'plant' && o.position.distanceTo(position) < radius) {
                                o.plagued = true;
                                o.plagueTimer = 100;
                                infected++;
                            }
                        }
                        showNotification(`ü¶† Plague spread! ${infected} organisms infected`);
                        playSound(300, 400);
                    }
                },
                'heal-rain': {
                    name: 'Healing Rain',
                    targetType: 'location',
                    execute: (position) => {
                        createHealingAura(position);
                        const radius = godMode.settings.effectRadius;
                        let healed = 0;
                        for (const o of organisms) {
                            if (!o.dead && o.position.distanceTo(position) < radius) {
                                o.energy = Math.min(100, o.energy + 50);
                                o.health = Math.min(100, o.health + 50);
                                healed++;
                            }
                        }
                        showNotification(`üåßÔ∏è Healing rain! Restored ${healed} organisms`);
                        playSound(900, 300);
                    }
                },
                'abundance': {
                    name: 'Abundance',
                    targetType: 'location',
                    execute: (position) => {
                        createGlowEffect({position}, 0x00FF88, 2000);
                        const radius = godMode.settings.effectRadius;
                        for (let i = 0; i < 20; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * radius;
                            const normal = position.clone().normalize();
                            const tangent = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                            const spawnPos = position.clone().add(tangent.multiplyScalar(dist));
                            const plant = new Organism('plant', spawnPos);
                            organisms.push(plant);
                        }
                        showNotification(`üåø Abundance! Spawned 20 plants`);
                    }
                },
                'drought': {
                    name: 'Drought',
                    targetType: 'location',
                    execute: (position) => {
                        createGlowEffect({position}, 0x996633, 2000);
                        const radius = godMode.settings.effectRadius;
                        let killed = 0;
                        for (const o of organisms) {
                            if (!o.dead && o.type === 'plant' && o.position.distanceTo(position) < radius) {
                                o.die();
                                killed++;
                            }
                        }
                        showNotification(`üèúÔ∏è Drought! Killed ${killed} plants`);
                    }
                },
                'raise': {
                    name: 'Raise Terrain',
                    targetType: 'terraform',
                    execute: (position) => {
                        modifyTerrain(position, godMode.settings.brushSize, godMode.settings.terraformStrength);
                        showNotification(`‚õ∞Ô∏è Raised terrain`);
                        checkAchievement('terraform');
                    }
                },
                'lower': {
                    name: 'Lower Terrain',
                    targetType: 'terraform',
                    execute: (position) => {
                        modifyTerrain(position, godMode.settings.brushSize, -godMode.settings.terraformStrength);
                        showNotification(`üåä Lowered terrain`);
                    }
                },
                'smooth': {
                    name: 'Smooth Terrain',
                    targetType: 'terraform',
                    execute: (position) => {
                        smoothTerrain(position, godMode.settings.brushSize);
                        showNotification(`üìè Smoothed terrain`);
                    }
                },
                'flatten': {
                    name: 'Flatten Terrain',
                    targetType: 'terraform',
                    execute: (position) => {
                        flattenTerrain(position, godMode.settings.brushSize);
                        showNotification(`üü© Flattened terrain`);
                    }
                },
                'mass-spawn': {
                    name: 'Mass Spawn',
                    targetType: 'location',
                    execute: (position) => {
                        // Show simple prompt for organism type
                        const type = prompt('Spawn type? (plant/herbivore/carnivore/humanoid)', 'plant');
                        if (!type) return;
                        const radius = godMode.settings.effectRadius;
                        for (let i = 0; i < godMode.settings.spawnCount; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const dist = Math.random() * radius;
                            const normal = position.clone().normalize();
                            const tangent = new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle));
                            const spawnPos = position.clone().add(tangent.multiplyScalar(dist));
                            organisms.push(new Organism(type, spawnPos));
                        }
                        createGlowEffect({position}, 0x00FFFF, 2000);
                        showNotification(`üéØ Spawned ${godMode.settings.spawnCount} ${type}s`);
                    }
                },
                'clear-area': {
                    name: 'Clear Area',
                    targetType: 'location',
                    execute: (position) => {
                        createGlowEffect({position}, 0xFFFFFF, 1500);
                        const radius = godMode.settings.effectRadius;
                        let removed = 0;
                        for (let i = organisms.length - 1; i >= 0; i--) {
                            if (organisms[i].position.distanceTo(position) < radius) {
                                if (organisms[i].mesh) planetGroup.remove(organisms[i].mesh);
                                organisms.splice(i, 1);
                                removed++;
                            }
                        }
                        showNotification(`üí• Cleared area! Removed ${removed} organisms`);
                    }
                },
                'balance': {
                    name: 'Balance Ecosystem',
                    targetType: 'global',
                    execute: () => {
                        const targets = {plant: 50, herbivore: 15, carnivore: 5, humanoid: 4};
                        const current = {plant: 0, herbivore: 0, carnivore: 0, humanoid: 0};
                        for (const o of organisms) {
                            if (!o.dead) current[o.type]++;
                        }
                        let changes = 0;
                        for (const type in targets) {
                            const diff = targets[type] - current[type];
                            if (diff > 0) {
                                spawnOrganism(type, diff);
                                changes += diff;
                            } else if (diff < 0) {
                                let toKill = -diff;
                                for (let i = organisms.length - 1; i >= 0 && toKill > 0; i--) {
                                    if (organisms[i].type === type && !organisms[i].dead) {
                                        organisms[i].die();
                                        toKill--;
                                        changes++;
                                    }
                                }
                            }
                        }
                        showNotification(`‚öñÔ∏è Balanced ecosystem! ${changes} changes`);
                        checkAchievement('balance');
                    }
                },
                'surplus': {
                    name: 'Food Surplus',
                    targetType: 'global',
                    execute: () => {
                        godMode.foodSurplusActive = true;
                        godMode.foodSurplusTimer = 200;
                        showNotification(`üåæ Food surplus activated for 200 time units!`);
                    }
                },
                'famine': {
                    name: 'Famine',
                    targetType: 'global',
                    execute: () => {
                        godMode.famineActive = true;
                        godMode.famineTimer = 200;
                        showNotification(`ü•Ä Famine activated for 200 time units!`);
                    }
                }
            };

            // Particle Effect Class
            class ParticleEffect {
                constructor(position, config) {
                    this.position = position.clone();
                    this.particles = [];
                    this.timer = 0;
                    this.duration = config.duration || 2000;
                    this.particleCount = config.count || 50;

                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(this.particleCount * 3);
                    const colors = new Float32Array(this.particleCount * 3);

                    for (let i = 0; i < this.particleCount; i++) {
                        const i3 = i * 3;
                        positions[i3] = position.x;
                        positions[i3 + 1] = position.y;
                        positions[i3 + 2] = position.z;

                        colors[i3] = config.color.r;
                        colors[i3 + 1] = config.color.g;
                        colors[i3 + 2] = config.color.b;

                        this.particles.push({
                            velocity: new THREE.Vector3(
                                (Math.random() - 0.5) * config.spread,
                                (Math.random() - 0.5) * config.spread,
                                (Math.random() - 0.5) * config.spread
                            ),
                            life: 1
                        });
                    }

                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                    const material = new THREE.PointsMaterial({
                        size: config.size || 0.5,
                        vertexColors: true,
                        transparent: true,
                        opacity: 0.8
                    });

                    this.mesh = new THREE.Points(geometry, material);
                    scene.add(this.mesh);
                }

                update(delta) {
                    this.timer += delta * 1000;
                    const progress = this.timer / this.duration;

                    if (progress >= 1) return true; // Signal completion

                    const positions = this.mesh.geometry.attributes.position.array;
                    const sizes = this.mesh.geometry.attributes.size?.array;

                    for (let i = 0; i < this.particleCount; i++) {
                        const i3 = i * 3;
                        const particle = this.particles[i];

                        // Apply velocity with gravity-like effect
                        particle.velocity.y -= delta * 2; // Gravity

                        positions[i3] += particle.velocity.x * delta;
                        positions[i3 + 1] += particle.velocity.y * delta;
                        positions[i3 + 2] += particle.velocity.z * delta;

                        // Add spiral effect
                        const angle = this.timer * 0.005;
                        const spiralForce = 0.1;
                        positions[i3] += Math.cos(angle + i) * spiralForce * delta;
                        positions[i3 + 2] += Math.sin(angle + i) * spiralForce * delta;

                        particle.life = 1 - progress;

                        // Animate size if available
                        if (sizes) {
                            sizes[i] = (0.2 + Math.sin(progress * Math.PI) * 0.8) * (particle.initialSize || 1);
                        }
                    }

                    this.mesh.geometry.attributes.position.needsUpdate = true;
                    if (sizes) this.mesh.geometry.attributes.size.needsUpdate = true;

                    // Fade out with easing
                    const easeOut = 1 - Math.pow(progress, 2);
                    this.mesh.material.opacity = easeOut * 0.9;

                    return false;
                }

                dispose() {
                    scene.remove(this.mesh);
                    this.mesh.geometry.dispose();
                    this.mesh.material.dispose();
                }
            }

            function updateParticleEffects(delta) {
                for (let i = activeEffects.length - 1; i >= 0; i--) {
                    const done = activeEffects[i].update(delta);
                    if (done) {
                        activeEffects[i].dispose();
                        activeEffects.splice(i, 1);
                    }
                }
            }

            function createGlowEffect(organism, color, duration) {
                const effect = new ParticleEffect(organism.position, {
                    count: 30,
                    color: new THREE.Color(color),
                    size: 0.6,
                    spread: 2,
                    duration: duration
                });
                activeEffects.push(effect);
            }

            function createExplosionEffect(position, color = 0xFF4400) {
                // Main explosion burst
                const explosion = new ParticleEffect(position, {
                    count: 80,
                    color: new THREE.Color(color),
                    size: 1.2,
                    spread: 8,
                    duration: 1500
                });
                activeEffects.push(explosion);

                // Secondary smoke ring
                setTimeout(() => {
                    const smoke = new ParticleEffect(position, {
                        count: 40,
                        color: new THREE.Color(0x555555),
                        size: 0.8,
                        spread: 4,
                        duration: 2000
                    });
                    activeEffects.push(smoke);
                }, 100);
            }

            function createLightningEffect(startPos, endPos) {
                // Create lightning bolt particles along path
                const steps = 12;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const pos = new THREE.Vector3().lerpVectors(startPos, endPos, t);

                    // Add random offset for jagged effect
                    pos.x += (Math.random() - 0.5) * 2;
                    pos.y += (Math.random() - 0.5) * 2;
                    pos.z += (Math.random() - 0.5) * 2;

                    const bolt = new ParticleEffect(pos, {
                        count: 15,
                        color: new THREE.Color(0x00DDFF),
                        size: 0.8,
                        spread: 1,
                        duration: 300
                    });
                    activeEffects.push(bolt);
                }

                // Impact flash
                createExplosionEffect(endPos, 0x00DDFF);
            }

            function createHealingAura(position) {
                // Rising healing particles
                const heal = new ParticleEffect(position, {
                    count: 60,
                    color: new THREE.Color(0x00FF88),
                    size: 0.5,
                    spread: 5,
                    duration: 2500
                });
                activeEffects.push(heal);

                // Pulsing ring effect
                setTimeout(() => {
                    const ring = new ParticleEffect(position, {
                        count: 40,
                        color: new THREE.Color(0x88FFAA),
                        size: 0.3,
                        spread: 8,
                        duration: 1500
                    });
                    activeEffects.push(ring);
                }, 200);
            }

            function createPlagueCloud(position) {
                // Dark spreading cloud
                const plague = new ParticleEffect(position, {
                    count: 100,
                    color: new THREE.Color(0x440044),
                    size: 1.0,
                    spread: 6,
                    duration: 3000
                });
                activeEffects.push(plague);
            }

            function createEvolutionEffect(position) {
                // DNA helix-like spiral
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const helix = new ParticleEffect(position, {
                            count: 50,
                            color: new THREE.Color(0xFF00FF),
                            size: 0.6,
                            spread: 3,
                            duration: 2000
                        });
                        activeEffects.push(helix);
                    }, i * 300);
                }
            }

            // Terraforming Functions
            function modifyTerrain(clickPoint, brushSize, strength) {
                const positions = planetGeometry.attributes.position;
                const colors = planetGeometry.attributes.color;

                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);

                    const vertex = new THREE.Vector3(x, y, z);
                    const dist = vertex.distanceTo(clickPoint);

                    if (dist < brushSize) {
                        const falloff = 1 - (dist / brushSize);
                        const adjustment = strength * falloff;

                        const len = vertex.length();
                        const nx = x / len, ny = y / len, nz = z / len;

                        const newLen = len + adjustment;
                        positions.setXYZ(i, nx * newLen, ny * newLen, nz * newLen);

                        // Recalculate biome color
                        const height = getTerrainHeight(nx, ny, nz);
                        const latitude = Math.asin(ny);
                        const color = getBiomeColor(height, latitude, nx, ny, nz);
                        colors.setXYZ(i, color.r, color.g, color.b);
                    }
                }

                positions.needsUpdate = true;
                colors.needsUpdate = true;
                planetGeometry.computeVertexNormals();
                terrainHeightCache.clear();
            }

            function smoothTerrain(clickPoint, brushSize) {
                const positions = planetGeometry.attributes.position;
                const colors = planetGeometry.attributes.color;
                const heights = [];

                // Calculate average height in brush area
                let totalHeight = 0;
                let count = 0;
                for (let i = 0; i < positions.count; i++) {
                    const vertex = new THREE.Vector3(positions.getX(i), positions.getY(i), positions.getZ(i));
                    const dist = vertex.distanceTo(clickPoint);
                    if (dist < brushSize) {
                        totalHeight += vertex.length();
                        count++;
                    }
                }
                const avgHeight = totalHeight / count;

                // Lerp towards average
                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const vertex = new THREE.Vector3(x, y, z);
                    const dist = vertex.distanceTo(clickPoint);

                    if (dist < brushSize) {
                        const falloff = 1 - (dist / brushSize);
                        const currentLen = vertex.length();
                        const newLen = currentLen + (avgHeight - currentLen) * falloff * 0.5;

                        const len = vertex.length();
                        const nx = x / len, ny = y / len, nz = z / len;
                        positions.setXYZ(i, nx * newLen, ny * newLen, nz * newLen);

                        const height = getTerrainHeight(nx, ny, nz);
                        const latitude = Math.asin(ny);
                        const color = getBiomeColor(height, latitude, nx, ny, nz);
                        colors.setXYZ(i, color.r, color.g, color.b);
                    }
                }

                positions.needsUpdate = true;
                colors.needsUpdate = true;
                planetGeometry.computeVertexNormals();
                terrainHeightCache.clear();
            }

            function flattenTerrain(clickPoint, brushSize) {
                const positions = planetGeometry.attributes.position;
                const colors = planetGeometry.attributes.color;
                const targetHeight = clickPoint.length();

                for (let i = 0; i < positions.count; i++) {
                    const x = positions.getX(i);
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const vertex = new THREE.Vector3(x, y, z);
                    const dist = vertex.distanceTo(clickPoint);

                    if (dist < brushSize) {
                        const falloff = 1 - (dist / brushSize);
                        const currentLen = vertex.length();
                        const newLen = currentLen + (targetHeight - currentLen) * falloff;

                        const len = vertex.length();
                        const nx = x / len, ny = y / len, nz = z / len;
                        positions.setXYZ(i, nx * newLen, ny * newLen, nz * newLen);

                        const height = getTerrainHeight(nx, ny, nz);
                        const latitude = Math.asin(ny);
                        const color = getBiomeColor(height, latitude, nx, ny, nz);
                        colors.setXYZ(i, color.r, color.g, color.b);
                    }
                }

                positions.needsUpdate = true;
                colors.needsUpdate = true;
                planetGeometry.computeVertexNormals();
                terrainHeightCache.clear();
            }

            function updateCursor(powerName) {
                document.body.className = powerName ? `cursor-${powerName}` : '';
            }

            function selectPower(powerName) {
                godMode.activePower = powerName;

                // Update button states
                document.querySelectorAll('.power-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.power === powerName);
                });

                // Show indicator
                const indicator = document.getElementById('active-power-indicator');
                const powerLabel = document.getElementById('active-power-name');
                indicator.style.display = 'block';
                powerLabel.textContent = POWERS[powerName].name;

                // Change cursor
                updateCursor(powerName);
            }

            function deselectPower() {
                godMode.activePower = null;
                document.querySelectorAll('.power-btn').forEach(btn => btn.classList.remove('active'));
                document.getElementById('active-power-indicator').style.display = 'none';
                document.body.className = '';
            }

            function initGodModeUI() {
                // Power button clicks
                document.querySelectorAll('.power-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const power = btn.dataset.power;
                        if (godMode.activePower === power) {
                            deselectPower();
                        } else {
                            selectPower(power);
                        }
                    });
                });

                // Deselect button
                document.getElementById('deselect-power').addEventListener('click', deselectPower);

                // ESC key to deselect
                document.addEventListener('keydown', e => {
                    if (e.key === 'Escape' && godMode.activePower) {
                        deselectPower();
                    }
                });

                // Brush size slider
                document.getElementById('brush-size-slider').addEventListener('input', e => {
                    godMode.settings.brushSize = parseFloat(e.target.value);
                    document.getElementById('brush-size-value').textContent = e.target.value;
                });
            }

            document.getElementById('btn-pause').onclick = () => {
                state.paused = !state.paused;
                document.getElementById('btn-pause').textContent = state.paused ? '‚ñ∂ Play' : '‚è∏ Pause';
            };

            document.getElementById('btn-speed').onclick = () => {
                const speeds = [1, 2, 5];
                state.speed = speeds[(speeds.indexOf(state.speed) + 1) % speeds.length];
                document.getElementById('btn-speed').textContent = `‚è© ${state.speed}x`;
            };

            document.getElementById('btn-evolve').onclick = () => {
                for (const o of organisms) {
                    if (o.brain && !o.dead) {
                        o.brain.mutate();
                        o.generation++;
                    }
                }
                showNotification('‚ö° Evolution boost applied!');
            };

            document.getElementById('btn-spawn-plants').onclick = () => {
                spawnOrganism('plant', 8);
                showNotification('üå≥ 8 plants spawned');
            };

            document.getElementById('btn-spawn-herbivores').onclick = () => {
                spawnOrganism('herbivore', 4);
                showNotification('ü¶å 4 herbivores spawned');
            };

            document.getElementById('btn-spawn-carnivores').onclick = () => {
                spawnOrganism('carnivore', 2);
                showNotification('ü¶Å 2 carnivores spawned');
            };

            document.getElementById('btn-spawn-humanoids').onclick = () => {
                spawnOrganism('humanoid', 2);
                showNotification('üë§ 2 humanoids spawned');
            };

            document.querySelectorAll('.filter-btn[data-filter]').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.filter-btn[data-filter]').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    updateCreatureList();
                });
            });

            document.getElementById('search-input').addEventListener('input', updateCreatureList);

            // Chart
            const ctx = document.getElementById('population-chart').getContext('2d');
            window.popChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'üå≥ Plants',
                            data: [],
                            borderColor: '#2d5016',
                            backgroundColor: 'rgba(45, 80, 22, 0.1)',
                            tension: 0.4,
                            borderWidth: 2
                        },
                        {
                            label: 'ü¶å Herbivores',
                            data: [],
                            borderColor: '#8b6914',
                            backgroundColor: 'rgba(139, 105, 20, 0.1)',
                            tension: 0.4,
                            borderWidth: 2
                        },
                        {
                            label: 'ü¶Å Carnivores',
                            data: [],
                            borderColor: '#8b0000',
                            backgroundColor: 'rgba(139, 0, 0, 0.1)',
                            tension: 0.4,
                            borderWidth: 2
                        },
                        {
                            label: 'üë§ Humanoids',
                            data: [],
                            borderColor: '#00d4ff',
                            backgroundColor: 'rgba(0, 212, 255, 0.1)',
                            tension: 0.4,
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#fff',
                                font: { family: 'system-ui', size: 10 }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: 'rgba(255,255,255,0.6)', font: { size: 9 } },
                            grid: { color: 'rgba(255,255,255,0.05)' }
                        },
                        y: {
                            ticks: { color: 'rgba(255,255,255,0.6)', font: { size: 9 } },
                            grid: { color: 'rgba(255,255,255,0.05)' }
                        }
                    }
                }
            });

            // Initial spawn - Increased populations for better survival
            spawnOrganism('plant', 100); // Increased for better sustainability
            spawnOrganism('herbivore', 20); // Balanced with more plants
            spawnOrganism('carnivore', 5); // Was 3, now 5
            spawnOrganism('humanoid', 4); // Was 2, now 4

            // Initialize cached counts immediately so stats show correctly
            updateOrganismCounts();

            showNotification(`üåç Planet Eden initialized with ${organisms.length} organisms`);

            // Initialize god mode UI
            initGodModeUI();

            // ========== POLISH FEATURES ==========

            // Settings & State
            const gameSettings = {
                particlesEnabled: true,
                shadowsEnabled: false,
                soundEnabled: true,
                showFPS: true,
                quality: 'medium',
                skipTutorial: false
            };

            // Load settings from localStorage
            const savedSettings = localStorage.getItem('planetEdenSettings');
            if (savedSettings) {
                Object.assign(gameSettings, JSON.parse(savedSettings));
            }

            // Simple sound system
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            function playSound(frequency, duration = 100) {
                if (!gameSettings.soundEnabled) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.frequency.value = frequency;
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration / 1000);
                osc.start();
                osc.stop(audioCtx.currentTime + duration / 1000);
            }

            // Welcome screen logic
            function showWelcomeScreen() {
                if (gameSettings.skipTutorial) {
                    document.getElementById('welcome-screen').style.display = 'none';
                    return;
                }
                document.getElementById('welcome-screen').style.display = 'flex';
            }

            document.getElementById('btn-start-game').onclick = () => {
                if (document.getElementById('skip-tutorial').checked) {
                    gameSettings.skipTutorial = true;
                    localStorage.setItem('planetEdenSettings', JSON.stringify(gameSettings));
                }
                document.getElementById('welcome-screen').style.display = 'none';
                playSound(800, 100);
            };

            document.getElementById('btn-show-settings').onclick = () => {
                document.getElementById('settings-panel').style.display = 'flex';
                playSound(600, 80);
            };

            document.getElementById('btn-close-settings').onclick = () => {
                document.getElementById('settings-panel').style.display = 'none';
                playSound(500, 80);
            };

            document.getElementById('btn-save-settings').onclick = () => {
                gameSettings.particlesEnabled = document.getElementById('setting-particles').checked;
                gameSettings.shadowsEnabled = document.getElementById('setting-shadows').checked;
                gameSettings.soundEnabled = document.getElementById('setting-sound').checked;
                gameSettings.showFPS = document.getElementById('setting-fps').checked;

                localStorage.setItem('planetEdenSettings', JSON.stringify(gameSettings));
                document.getElementById('settings-panel').style.display = 'none';

                // Apply settings
                document.getElementById('fps-counter').classList.toggle('show', gameSettings.showFPS);
                showNotification('‚öôÔ∏è Settings saved!');
                playSound(900, 150);
            };

            document.getElementById('btn-close-help').onclick = () => {
                document.getElementById('help-panel').style.display = 'none';
                playSound(500, 80);
            };

            // Quality presets
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    gameSettings.quality = btn.dataset.preset;
                    playSound(700, 80);
                });
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', e => {
                // Prevent shortcuts when typing in input
                if (e.target.tagName === 'INPUT') return;

                if (e.key === ' ') {
                    e.preventDefault();
                    state.paused = !state.paused;
                    document.getElementById('btn-pause').textContent = state.paused ? '‚ñ∂ Play' : '‚è∏ Pause';
                    playSound(state.paused ? 500 : 700, 80);
                }

                if (e.key.toLowerCase() === 'h') {
                    const helpPanel = document.getElementById('help-panel');
                    helpPanel.style.display = helpPanel.style.display === 'none' ? 'flex' : 'none';
                    playSound(600, 80);
                }

                if (e.key.toLowerCase() === 's' && !e.ctrlKey) {
                    document.getElementById('settings-panel').style.display = 'flex';
                    playSound(600, 80);
                }

                if (e.key.toLowerCase() === 'q') {
                    const speeds = [1, 2, 5];
                    const currentIndex = speeds.indexOf(state.speed);
                    state.speed = speeds[currentIndex > 0 ? currentIndex - 1 : 0];
                    document.getElementById('btn-speed').textContent = `‚è© ${state.speed}x`;
                    playSound(550, 60);
                }

                if (e.key.toLowerCase() === 'e') {
                    const speeds = [1, 2, 5];
                    const currentIndex = speeds.indexOf(state.speed);
                    state.speed = speeds[currentIndex < speeds.length - 1 ? currentIndex + 1 : speeds.length - 1];
                    document.getElementById('btn-speed').textContent = `‚è© ${state.speed}x`;
                    playSound(750, 60);
                }

                // Save/Load world state
                if (e.ctrlKey && e.key.toLowerCase() === 's') {
                    e.preventDefault();
                    const worldState = {
                        time: state.time,
                        organisms: organisms.map(o => ({
                            type: o.type,
                            position: {x: o.position.x, y: o.position.y, z: o.position.z},
                            energy: o.energy,
                            health: o.health,
                            age: o.age,
                            generation: o.generation,
                            dead: o.dead
                        }))
                    };
                    localStorage.setItem('planetEdenWorld', JSON.stringify(worldState));
                    showNotification('üíæ World saved!');
                    playSound(1000, 200);
                }

                if (e.ctrlKey && e.key.toLowerCase() === 'l') {
                    e.preventDefault();
                    const savedWorld = localStorage.getItem('planetEdenWorld');
                    if (savedWorld) {
                        const worldState = JSON.parse(savedWorld);
                        // Clear current organisms
                        for (const o of organisms) {
                            if (o.mesh) planetGroup.remove(o.mesh);
                        }
                        organisms.length = 0;

                        // Restore organisms
                        for (const data of worldState.organisms) {
                            const pos = new THREE.Vector3(data.position.x, data.position.y, data.position.z);
                            const organism = new Organism(data.type, pos);
                            organism.energy = data.energy;
                            organism.health = data.health;
                            organism.age = data.age;
                            organism.generation = data.generation;
                            if (data.dead) organism.die();
                            organisms.push(organism);
                        }

                        state.time = worldState.time;
                        showNotification(`üìÇ World loaded! ${organisms.length} organisms restored`);
                        playSound(1200, 200);
                    } else {
                        showNotification('‚ùå No saved world found');
                        playSound(300, 150);
                    }
                }
            });

            // FPS Counter
            let frameCount = 0;
            let fpsTime = performance.now();
            function updateFPS() {
                frameCount++;
                const currentTime = performance.now();
                if (currentTime >= fpsTime + 1000) {
                    const fps = Math.round((frameCount * 1000) / (currentTime - fpsTime));
                    document.getElementById('fps-counter').textContent = `${fps} FPS`;

                    // Color code based on performance
                    const counter = document.getElementById('fps-counter');
                    if (fps >= 55) counter.style.color = '#00ff88';
                    else if (fps >= 30) counter.style.color = '#ffaa00';
                    else counter.style.color = '#ff4444';

                    frameCount = 0;
                    fpsTime = currentTime;
                }
            }

            // Apply initial settings
            document.getElementById('setting-particles').checked = gameSettings.particlesEnabled;
            document.getElementById('setting-shadows').checked = gameSettings.shadowsEnabled;
            document.getElementById('setting-sound').checked = gameSettings.soundEnabled;
            document.getElementById('setting-fps').checked = gameSettings.showFPS;
            document.getElementById('fps-counter').classList.toggle('show', gameSettings.showFPS);

            // ========== DEVELOPER FEATURES INITIALIZATION ==========

            // Developer Console State
            const devConsole = {
                visible: false,
                activeTab: 'performance',
                performanceHistory: [],
                spatialGridVisible: false
            };

            // Performance tracking
            const perfMetrics = {
                frameTime: 0,
                drawCalls: 0,
                triangles: 0,
                memory: 0,
                fps: 60,
                fpsHistory: [] // Track last 60 FPS samples for graph
            };

            // Developer Settings (live tweakable parameters)
            const devSettings = {
                mutationRate: 0.1,
                reproductionThreshold: 60,
                energyCostMultiplier: 1.0,
                perceptionRange: 20,
                evolutionSpeed: 1.0,
                gravity: 1.0
            };

            // Developer Tools Floating Action Menu
            const devMenu = document.getElementById('dev-tools-menu');
            const devMenuToggle = document.getElementById('dev-menu-toggle');
            let devMenuOpen = false;

            devMenuToggle.addEventListener('click', () => {
                devMenuOpen = !devMenuOpen;
                devMenu.classList.toggle('hidden', !devMenuOpen);
                devMenuToggle.style.transform = devMenuOpen ? 'rotate(45deg)' : 'rotate(0deg)';
                playSound(700, 100);
            });

            // On-screen button: Performance Console
            document.getElementById('btn-dev-console').addEventListener('click', () => {
                devConsole.visible = !devConsole.visible;
                document.getElementById('dev-console').classList.toggle('show', devConsole.visible);
                playSound(700, 100);
                devMenuOpen = false;
                devMenu.classList.add('hidden');
                devMenuToggle.style.transform = 'rotate(0deg)';
            });

            // On-screen button: Developer Settings
            document.getElementById('btn-dev-settings').addEventListener('click', () => {
                const settingsPanel = document.getElementById('dev-settings-panel');
                settingsPanel.classList.toggle('show');
                playSound(700, 100);
                devMenuOpen = false;
                devMenu.classList.add('hidden');
                devMenuToggle.style.transform = 'rotate(0deg)';
            });

            // On-screen button: Benchmark
            document.getElementById('btn-benchmark').addEventListener('click', () => {
                runBenchmark();
                devMenuOpen = false;
                devMenu.classList.add('hidden');
                devMenuToggle.style.transform = 'rotate(0deg)';
            });

            // On-screen button: Code Viewer
            document.getElementById('btn-code-viewer').addEventListener('click', () => {
                document.getElementById('code-viewer').classList.add('show');
                playSound(700, 100);
                devMenuOpen = false;
                devMenu.classList.add('hidden');
                devMenuToggle.style.transform = 'rotate(0deg)';
            });

            // On-screen button: Export Menu (shows dev console Export tab)
            document.getElementById('btn-export-menu').addEventListener('click', () => {
                devConsole.visible = true;
                devConsole.activeTab = 'export';
                document.getElementById('dev-console').classList.add('show');

                // Switch to export tab
                document.querySelectorAll('.dev-tab').forEach(t => t.classList.remove('active'));
                document.querySelector('[data-tab="export"]').classList.add('active');
                document.querySelectorAll('.dev-section').forEach(s => s.classList.remove('active'));
                document.getElementById('export-section').classList.add('active');

                playSound(700, 100);
                devMenuOpen = false;
                devMenu.classList.add('hidden');
                devMenuToggle.style.transform = 'rotate(0deg)';
            });

            // Dev Console Tab Switching
            document.querySelectorAll('.dev-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    const tabName = tab.dataset.tab;
                    devConsole.activeTab = tabName;

                    // Update active tab styling
                    document.querySelectorAll('.dev-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');

                    // Show corresponding section
                    document.querySelectorAll('.dev-section').forEach(s => s.classList.remove('active'));
                    document.getElementById(tabName + '-section').classList.add('active');

                    playSound(600, 50);
                });
            });

            // Close dev console button
            document.getElementById('close-dev-console').addEventListener('click', () => {
                devConsole.visible = false;
                document.getElementById('dev-console').classList.remove('show');
                playSound(500, 80);
            });


            // Developer Settings Sliders
            const sliders = [
                { id: 'mutation', key: 'mutationRate', format: (v) => v + '%' },
                { id: 'reproduction', key: 'reproductionThreshold', format: (v) => v },
                { id: 'energy', key: 'energyCostMultiplier', format: (v) => v.toFixed(1) + 'x' },
                { id: 'perception', key: 'perceptionRange', format: (v) => v },
                { id: 'evo-speed', key: 'evolutionSpeed', format: (v) => v.toFixed(1) + 'x' },
                { id: 'gravity', key: 'gravity', format: (v) => v.toFixed(1) + 'x' }
            ];

            sliders.forEach(({ id, key, format }) => {
                const slider = document.getElementById(`slider-${id}`);
                const valueDisplay = document.getElementById(`val-${id}`);

                slider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    devSettings[key] = id === 'mutation' ? value / 100 : value;
                    valueDisplay.textContent = format(value);
                });
            });

            document.getElementById('reset-dev-settings').addEventListener('click', () => {
                devSettings.mutationRate = 0.1;
                devSettings.reproductionThreshold = 60;
                devSettings.energyCostMultiplier = 1.0;
                devSettings.perceptionRange = 20;
                devSettings.evolutionSpeed = 1.0;
                devSettings.gravity = 1.0;

                document.getElementById('slider-mutation').value = 10;
                document.getElementById('slider-reproduction').value = 60;
                document.getElementById('slider-energy').value = 1;
                document.getElementById('slider-perception').value = 20;
                document.getElementById('slider-evo-speed').value = 1;
                document.getElementById('slider-gravity').value = 1;

                sliders.forEach(({ id, format }) => {
                    const slider = document.getElementById(`slider-${id}`);
                    document.getElementById(`val-${id}`).textContent = format(parseFloat(slider.value));
                });

                showNotification('üîß Settings reset to defaults');
                playSound(800, 150);
            });

            // Export Functions
            document.getElementById('export-csv').addEventListener('click', () => {
                exportPopulationCSV();
            });

            document.getElementById('export-json').addEventListener('click', () => {
                exportWorldJSON();
            });

            document.getElementById('export-benchmark').addEventListener('click', () => {
                exportBenchmark();
            });

            document.getElementById('export-organism').addEventListener('click', () => {
                if (selected) {
                    exportOrganism(selected);
                } else {
                    showNotification('‚ö†Ô∏è No organism selected');
                }
            });

            function exportPopulationCSV() {
                const csv = ['Time,Plants,Herbivores,Carnivores,Humanoids,Total,AvgGeneration'];
                const data = `${state.time.toFixed(0)},${populationCounts.plant},${populationCounts.herbivore},${populationCounts.carnivore},${populationCounts.humanoid},${organisms.length},${(organisms.reduce((sum, o) => sum + o.generation, 0) / organisms.length).toFixed(1)}`;
                csv.push(data);

                const blob = new Blob([csv.join('\\n')], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `planet-eden-population-${Date.now()}.csv`;
                a.click();

                showNotification('üìä Population data exported');
                playSound(1000, 150);
            }

            function exportWorldJSON() {
                const worldData = {
                    timestamp: Date.now(),
                    time: state.time,
                    organisms: organisms.map(o => ({
                        id: o.id,
                        type: o.type,
                        position: { x: o.position.x, y: o.position.y, z: o.position.z },
                        energy: o.energy,
                        health: o.health,
                        age: o.age,
                        generation: o.generation,
                        dead: o.dead
                    })),
                    settings: devSettings,
                    populationCounts
                };

                const blob = new Blob([JSON.stringify(worldData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `planet-eden-world-${Date.now()}.json`;
                a.click();

                showNotification('üì¶ World state exported');
                playSound(1000, 150);
            }

            function exportOrganism(organism) {
                const data = {
                    id: organism.id,
                    type: organism.type,
                    generation: organism.generation,
                    age: organism.age,
                    energy: organism.energy,
                    health: organism.health,
                    neuralNetwork: organism.brain ? {
                        weights: organism.brain.weights,
                        complexity: organism.type === 'humanoid' ? 2 : 1,
                        weightCount: organism.brain.weights.length
                    } : null
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `organism-${organism.type}-${organism.id}.json`;
                a.click();

                showNotification(`üß¨ Organism #${organism.id} exported`);
                playSound(900, 150);
            }

            function exportBenchmark() {
                const benchData = {
                    timestamp: Date.now(),
                    avgFPS: Math.round(1000 / perfMetrics.frameTime),
                    frameTime: perfMetrics.frameTime.toFixed(2),
                    drawCalls: perfMetrics.drawCalls,
                    triangles: perfMetrics.triangles,
                    memory: perfMetrics.memory,
                    organisms: organisms.length,
                    renderer: renderer.info.render,
                    gpu: renderer.getContext().getParameter(renderer.getContext().getExtension('WEBGL_debug_renderer_info').UNMASKED_RENDERER_WEBGL)
                };

                const blob = new Blob([JSON.stringify(benchData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `planet-eden-benchmark-${Date.now()}.json`;
                a.click();

                showNotification('‚ö° Benchmark data exported');
                playSound(1000, 150);
            }

            // Code Viewer
            document.getElementById('close-code-viewer').addEventListener('click', () => {
                document.getElementById('code-viewer-modal').classList.remove('show');
                playSound(500, 80);
            });

            // Benchmark Modal
            document.getElementById('close-benchmark').addEventListener('click', () => {
                document.getElementById('benchmark-results').classList.remove('show');
                playSound(500, 80);
            });

            document.getElementById('share-benchmark').addEventListener('click', () => {
                const score = document.getElementById('benchmark-score').textContent;
                const text = `I scored ${score} on Planet Eden Performance Benchmark! üåç‚ö°\\n\\nhttps://markjspivey-xwisee.github.io/planet-eden/`;

                navigator.clipboard.writeText(text).then(() => {
                    showNotification('üìã Benchmark copied to clipboard!');
                    playSound(1000, 150);
                });
            });

            // Run Performance Benchmark
            function runBenchmark() {
                showNotification('‚ö° Running benchmark...');
                playSound(700, 100);

                const benchStart = performance.now();
                let frameCount = 0;
                let totalFrameTime = 0;
                const duration = 5000; // 5 second benchmark

                const benchInterval = setInterval(() => {
                    frameCount++;
                    totalFrameTime += perfMetrics.frameTime;

                    if (performance.now() - benchStart >= duration) {
                        clearInterval(benchInterval);

                        const avgFPS = Math.round(frameCount / (duration / 1000));
                        const avgFrameTime = (totalFrameTime / frameCount).toFixed(2);
                        const score = Math.round(avgFPS * (organisms.length / 100) * (1000 / avgFrameTime));

                        document.getElementById('benchmark-score').textContent = score;
                        document.getElementById('bench-fps').textContent = avgFPS;
                        document.getElementById('bench-frame-time').textContent = avgFrameTime + 'ms';
                        document.getElementById('bench-entities').textContent = organisms.length;

                        try {
                            const gl = renderer.getContext();
                            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                            const gpu = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                            document.getElementById('bench-gpu').textContent = gpu.substring(0, 30);
                        } catch (e) {
                            document.getElementById('bench-gpu').textContent = 'Unknown';
                        }

                        let rating = 'Poor';
                        if (score > 5000) rating = 'Excellent! üèÜ';
                        else if (score > 3000) rating = 'Very Good üåü';
                        else if (score > 1500) rating = 'Good ‚úì';
                        else if (score > 800) rating = 'Fair';

                        document.getElementById('benchmark-rating').textContent = rating;
                        document.getElementById('benchmark-results').classList.add('show');

                        playSound(1200, 300);
                    }
                }, 16);
            }

            // Matrix Mode Easter Egg
            function activateMatrixMode() {
                showNotification('üéÆ Matrix Mode Activated!');
                playSound(1500, 500);

                const canvas = document.getElementById('matrix-rain');
                canvas.classList.add('active');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                const ctx = canvas.getContext('2d');

                const chars = 'ÔΩ±ÔΩ≤ÔΩ≥ÔΩ¥ÔΩµÔΩ∂ÔΩ∑ÔΩ∏ÔΩπÔΩ∫ÔΩªÔΩºÔΩΩÔΩæÔΩøÔæÄÔæÅÔæÇÔæÉÔæÑÔæÖÔæÜÔæáÔæàÔæâÔæäÔæãÔæåÔæçÔæéÔæèÔæêÔæëÔæíÔæìÔæîÔæïÔæñÔæóÔæòÔæôÔæöÔæõÔæúÔæù01';
                const fontSize = 14;
                const columns = canvas.width / fontSize;
                const drops = Array(Math.floor(columns)).fill(1);

                let matrixInterval = setInterval(() => {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#0F0';
                    ctx.font = fontSize + 'px monospace';

                    for (let i = 0; i < drops.length; i++) {
                        const text = chars[Math.floor(Math.random() * chars.length)];
                        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                        if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                            drops[i] = 0;
                        }
                        drops[i]++;
                    }
                }, 33);

                // Auto-disable after 10 seconds
                setTimeout(() => {
                    clearInterval(matrixInterval);
                    canvas.classList.remove('active');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    showNotification('Matrix Mode Deactivated');
                }, 10000);
            }

            // Update Performance Metrics
            function updateDevMetrics() {
                if (!devConsole.visible) return;

                // Get renderer info
                const info = renderer.info;
                perfMetrics.drawCalls = info.render.calls;
                perfMetrics.triangles = info.render.triangles;

                // Memory estimate
                if (performance.memory) {
                    perfMetrics.memory = (performance.memory.usedJSHeapSize / 1048576).toFixed(1);
                }

                // Calculate FPS
                perfMetrics.fps = perfMetrics.frameTime > 0 ? Math.round(1000 / perfMetrics.frameTime) : 60;
                perfMetrics.fpsHistory.push(perfMetrics.fps);
                if (perfMetrics.fpsHistory.length > 60) perfMetrics.fpsHistory.shift();

                // Update UI
                document.getElementById('metric-frame-time').textContent = perfMetrics.frameTime.toFixed(2) + 'ms';
                document.getElementById('metric-draw-calls').textContent = perfMetrics.drawCalls;
                document.getElementById('metric-triangles').textContent = perfMetrics.triangles.toLocaleString();
                document.getElementById('metric-particles').textContent = activeEffects.length;
                document.getElementById('metric-memory').textContent = perfMetrics.memory;

                // Draw performance graph
                const perfCanvas = document.getElementById('performance-graph');
                const perfCtx = perfCanvas.getContext('2d');
                perfCanvas.width = 600;
                perfCanvas.height = 150;

                perfCtx.clearRect(0, 0, perfCanvas.width, perfCanvas.height);

                // Draw grid
                perfCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                perfCtx.lineWidth = 1;
                for (let i = 0; i <= 60; i += 10) {
                    const y = perfCanvas.height - (i / 60) * perfCanvas.height;
                    perfCtx.beginPath();
                    perfCtx.moveTo(0, y);
                    perfCtx.lineTo(perfCanvas.width, y);
                    perfCtx.stroke();
                }

                // Draw FPS line
                if (perfMetrics.fpsHistory.length > 1) {
                    perfCtx.strokeStyle = 'rgba(0, 212, 255, 0.8)';
                    perfCtx.lineWidth = 2;
                    perfCtx.beginPath();

                    const step = perfCanvas.width / 60;
                    perfMetrics.fpsHistory.forEach((fps, i) => {
                        const x = i * step;
                        const y = perfCanvas.height - (Math.min(fps, 60) / 60) * perfCanvas.height;
                        if (i === 0) perfCtx.moveTo(x, y);
                        else perfCtx.lineTo(x, y);
                    });
                    perfCtx.stroke();

                    // Fill area under curve
                    perfCtx.lineTo(perfMetrics.fpsHistory.length * step, perfCanvas.height);
                    perfCtx.lineTo(0, perfCanvas.height);
                    perfCtx.closePath();
                    perfCtx.fillStyle = 'rgba(0, 212, 255, 0.2)';
                    perfCtx.fill();
                }

                // Draw labels
                perfCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                perfCtx.font = '10px monospace';
                perfCtx.fillText('60 FPS', 5, 12);
                perfCtx.fillText('30 FPS', 5, perfCanvas.height / 2 + 4);
                perfCtx.fillText('0 FPS', 5, perfCanvas.height - 4);

                // Entity stats
                const living = organisms.filter(o => !o.dead).length;
                const avgGen = organisms.length > 0 ? organisms.reduce((sum, o) => sum + o.generation, 0) / organisms.length : 0;

                document.getElementById('metric-total-organisms').textContent = organisms.length;
                document.getElementById('metric-living').textContent = living;
                document.getElementById('metric-dead').textContent = organisms.length - living;
                document.getElementById('metric-avg-gen').textContent = avgGen.toFixed(1);
                document.getElementById('metric-grid-cells').textContent = spatialGrid.gridSize * spatialGrid.gridSize;

                // Neural network display (if organism selected)
                const neuralWeights = document.getElementById('neural-weights');
                const nnCanvas = document.getElementById('neural-network-viz');
                const nnCtx = nnCanvas.getContext('2d');

                if (selected && selected.brain && !selected.dead) {
                    const weights = selected.brain.weights;

                    // Draw neural network visualization
                    nnCanvas.width = 600;
                    nnCanvas.height = 300;
                    nnCtx.clearRect(0, 0, nnCanvas.width, nnCanvas.height);

                    const inputCount = 8; // Perception inputs
                    const hiddenCount = Math.ceil(weights.length / 2);
                    const outputCount = 3; // Movement outputs

                    const drawNeuron = (x, y, active) => {
                        nnCtx.beginPath();
                        nnCtx.arc(x, y, 8, 0, Math.PI * 2);
                        nnCtx.fillStyle = active ? 'rgba(0, 212, 255, 0.8)' : 'rgba(100, 100, 100, 0.5)';
                        nnCtx.fill();
                        nnCtx.strokeStyle = 'rgba(0, 212, 255, 0.4)';
                        nnCtx.lineWidth = 2;
                        nnCtx.stroke();
                    };

                    const drawConnection = (x1, y1, x2, y2, weight) => {
                        const alpha = Math.min(Math.abs(weight), 1);
                        const color = weight > 0 ? `rgba(0, 255, 100, ${alpha * 0.6})` : `rgba(255, 50, 50, ${alpha * 0.6})`;
                        nnCtx.strokeStyle = color;
                        nnCtx.lineWidth = Math.abs(weight) * 2;
                        nnCtx.beginPath();
                        nnCtx.moveTo(x1, y1);
                        nnCtx.lineTo(x2, y2);
                        nnCtx.stroke();
                    };

                    // Input layer
                    const inputX = 50;
                    const inputSpacing = nnCanvas.height / (inputCount + 1);
                    for (let i = 0; i < inputCount; i++) {
                        const y = inputSpacing * (i + 1);
                        drawNeuron(inputX, y, true);
                    }

                    // Hidden layer
                    const hiddenX = 250;
                    const hiddenSpacing = nnCanvas.height / (hiddenCount + 1);
                    for (let i = 0; i < hiddenCount; i++) {
                        const y = hiddenSpacing * (i + 1);
                        drawNeuron(hiddenX, y, true);

                        // Draw connections from inputs to hidden
                        for (let j = 0; j < inputCount; j++) {
                            const inputY = inputSpacing * (j + 1);
                            const weightIdx = (i * inputCount + j) % weights.length;
                            drawConnection(inputX, inputY, hiddenX, y, weights[weightIdx]);
                        }
                    }

                    // Output layer
                    const outputX = 500;
                    const outputSpacing = nnCanvas.height / (outputCount + 1);
                    for (let i = 0; i < outputCount; i++) {
                        const y = outputSpacing * (i + 1);
                        drawNeuron(outputX, y, true);

                        // Draw connections from hidden to output
                        for (let j = 0; j < hiddenCount; j++) {
                            const hiddenY = hiddenSpacing * (j + 1);
                            const weightIdx = (inputCount * hiddenCount + i * hiddenCount + j) % weights.length;
                            drawConnection(hiddenX, hiddenY, outputX, y, weights[weightIdx]);
                        }
                    }

                    // Labels
                    nnCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    nnCtx.font = '12px monospace';
                    nnCtx.fillText('Inputs', inputX - 20, 20);
                    nnCtx.fillText('Hidden', hiddenX - 20, 20);
                    nnCtx.fillText('Outputs', outputX - 25, 20);

                    // Weight list
                    neuralWeights.innerHTML = `
                        <strong style="color: var(--text-bright);">Organism #${selected.id} (${selected.type})</strong><br>
                        <span style="color: var(--text-dim);">Generation: ${selected.generation} | Weights: ${weights.length}</span><br><br>
                        <strong style="color: var(--accent-blue);">Neural Network Weights:</strong><br>
                        <code style="color: var(--text-bright); display: block; max-height: 150px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; margin-top: 4px; font-size: 9px;">
                            ${weights.map((w, i) => `w[${i}]: ${w.toFixed(4)}`).join('<br>')}
                        </code>
                    `;
                } else {
                    nnCtx.clearRect(0, 0, nnCanvas.width, nnCanvas.height);
                    neuralWeights.innerHTML = '<span style="color: var(--text-dim);">Select a living organism to view its neural network</span>';
                }
            }

            // Show welcome screen on first load
            showWelcomeScreen();

            let lastTime = performance.now();

            function animate() {
                requestAnimationFrame(animate);

                const frameStart = performance.now();
                const currentTime = frameStart;
                const delta = ((currentTime - lastTime) / 1000) * state.speed;
                lastTime = currentTime;

                if (!state.paused) {
                    state.time += delta;
                    planetGroup.rotation.y += 0.0002 * delta;
                    updateEcosystem(delta);

                    // Day/Night Cycle
                    const prevDayTime = state.dayTime;
                    state.dayTime = (state.dayTime + delta * state.dayNightSpeed) % 1;

                    // Check for day/night achievements
                    if (prevDayTime < 0.5 && state.dayTime >= 0.5) checkAchievement('sunrise');
                    if (prevDayTime < 0.95 && state.dayTime >= 0.95) checkAchievement('nightOwl');

                    // Auto-save every 2 minutes
                    if (state.time - state.lastAutoSave > 120) {
                        state.lastAutoSave = state.time;
                        const worldState = {
                            time: state.time,
                            dayTime: state.dayTime,
                            organisms: organisms.map(o => ({
                                type: o.type,
                                position: {x: o.position.x, y: o.position.y, z: o.position.z},
                                energy: o.energy,
                                health: o.health,
                                age: o.age,
                                generation: o.generation,
                                dead: o.dead
                            }))
                        };
                        localStorage.setItem('planetEdenAutoSave', JSON.stringify(worldState));
                    }
                }

                // Update lighting based on time of day
                const sunPhase = Math.sin(state.dayTime * Math.PI * 2); // -1 to 1
                const lightIntensity = Math.max(0.3, (sunPhase + 1) * 0.6); // 0.3 to 1.5

                sunLight.intensity = lightIntensity * 1.8;
                ambientLight.intensity = lightIntensity * 0.6;

                // Change sun color based on time (warmer at sunrise/sunset)
                const isRising = state.dayTime < 0.25 || state.dayTime > 0.75;
                const sunsetStrength = isRising ? Math.abs(Math.cos(state.dayTime * Math.PI * 4)) : 0;
                const sunColor = new THREE.Color().lerpColors(
                    new THREE.Color(0xffffee), // Day color
                    new THREE.Color(0xff8844), // Sunset color
                    sunsetStrength
                );
                sunLight.color = sunColor;

                // Move sun position
                const sunAngle = state.dayTime * Math.PI * 2;
                sunLight.position.x = Math.cos(sunAngle) * 200;
                sunLight.position.y = Math.sin(sunAngle) * 200;
                sunLight.position.z = -100;

                // Change background color
                const skyColorDay = new THREE.Color(0x87ceeb);
                const skyColorNight = new THREE.Color(0x0a0a1a);
                const skyColorSunset = new THREE.Color(0x4a2a5a);

                let skyColor;
                if (sunPhase > 0.7) {
                    // Day
                    skyColor = skyColorDay;
                } else if (sunPhase < -0.7) {
                    // Night
                    skyColor = skyColorNight;
                } else {
                    // Sunrise/Sunset
                    const t = (sunPhase + 0.7) / 1.4; // 0 to 1
                    skyColor = new THREE.Color().lerpColors(skyColorNight, skyColorDay, t);
                    if (Math.abs(sunPhase) < 0.3) {
                        skyColor.lerp(skyColorSunset, (0.3 - Math.abs(sunPhase)) / 0.3);
                    }
                }
                scene.background = skyColor;

                camera.position.x = Math.cos(cameraAngle) * cameraDistance;
                camera.position.z = Math.sin(cameraAngle) * cameraDistance;
                camera.position.y = cameraHeight;
                camera.lookAt(planetGroup.position);

                // Update particle effects
                updateParticleEffects(delta);

                updateUI();

                // Track frame time for dev console
                perfMetrics.frameTime = performance.now() - frameStart;
                updateDevMetrics();

                renderer.render(scene, camera);
            }

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            console.log('‚úì Planet Eden Complete - Ready');
        }
    </script>
</body>
</html>
